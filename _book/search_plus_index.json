{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 依赖安装 gitbook install 启动项目 gitbook serve 构建项目 gitbook build book.json plugins中追加项后 项目启动会报错，命令行中执行\"gitbook install\"方可正常运行 错误信息：Error: Couldn't locate plugins ${插件名称}, Run 'gitbook install' to install plugins from registry.book.json中使用的插件 search-pro：高级搜索 "},"doc/HTML/HTML.html":{"url":"doc/HTML/HTML.html","title":"HTML","keywords":"","body":""},"doc/CSS/CSS.html":{"url":"doc/CSS/CSS.html","title":"CSS","keywords":"","body":"相邻兄弟选择器(Adjacent sibling selector) 适用场景：二者有相同的父元素，选择紧接在一个元素后的另一个元素 e.g. 给紧跟在 h1标签 后出现的 p标签 设置上外边距 h1 + p {margin-top:50px;} "},"doc/JavaScript/JavaScript.html":{"url":"doc/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript.md "},"doc/JavaScript/DOM.html":{"url":"doc/JavaScript/DOM.html","title":"DOM","keywords":"","body":"event事件对象 event.target 和 event.currentTarget的区别 event.currentTarget 会返回当前触发事件元素，event.target会返回触发事件的源头元素 event.currentTarget 在控制台展开查看的时候已经不存在了。如果想拿到它，可以使用变量进行缓存，然后再进行操作 1 2 3 document.querySelector('.ok').addEventListener('click', function (event) { console.log('event', event); // 展开后发现 event.currentTarget 值为null console.log('event.currentTarget', event.currentTarget); // 值正常 }); "},"doc/CodeSegment/CodeSegment.html":{"url":"doc/CodeSegment/CodeSegment.html","title":"CodeSegment","keywords":"","body":"css 文字单行超出省略号儿 overflow: hidden; //超出的文本隐藏 text-overflow: ellipsis; //溢出用省略号显示 white-space: nowrap; //溢出不换行 文字n行超出省略号儿 overflow: hidden; text-overflow: ellipsis; display: -webkit-box; // 作为弹性伸缩盒子模型显示。 -webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列 -webkit-line-clamp: n; // n为显示的行数 获取数组中某项的索引，indexOf Polyfill !Array.prototype.indexOf && Array.prototype.indexOf = function(item) { for(var i = 0; i 获取url query参数值 function getSearchParams() { const { search } = window.location; if (!search) return ''; return search .slice(1) .split('&') .map((group) => group.split('=')) .reduce((searchParamsObj, item) => { searchParamsObj[item[0]] = item[1]; return searchParamsObj; }, {}); } 扩展运算符 合并对象 合并对象1 const obj1 = { name: 'xiaohei', age: 12, eat: 'fruit', } const obj2 = { ...obj1, color: 'black', } const {eat, ...targetObj} = obj2; // 注意前面的const console.log(targetObj); /* { name: 'xiaohei', age: 12, color: 'black', } */ 合并对象1 // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(''); } // good function concatenateAll(...args) { return args.join(''); } 将类数组转换为数组 function fn(){return arguments}; const arrayLike = fn('a', 'b', 'c', 'd'); console.log(Object.prototype.toString.call(arrayLike)); // [object Arguments] const arr1 = Array.prototype.slice.call(arrayLike); console.log(Object.prototype.toString.call(arr1)); // [object Array] const arr2 = [...arrayLike]; console.log(Object.prototype.toString.call(arr2)); // [object Array] 解构 Destructuring 对象解构 // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`; } // good function getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`; } // best function getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`; } 数组解构 const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; "},"doc/Chrome/Chrome.html":{"url":"doc/Chrome/Chrome.html","title":"Chrome","keywords":"","body":"Chrome65+ local overrides 介绍：通过overrides可以在浏览器中直接修改一些请求的返回数据，类似于使用fiddler代理抓包重写返回数据一样 用途：调试线上（pre || prd）页面接口返回的静态资源（html、css、js、图片） 使用方法： 打开开发者工具的sources页，找到overrides tab 点击“Select folder for overrides”按钮选择本地文件夹 勾选“Enable local overrides” 注：勾选状态下 如果选择的本地文件夹不为空，network tab处会出现一个黄色的三角形提示；如果文件夹中的 文件夹路径、文件名 与 network中x请求全等，则x请求的返回结果就会被立即重写 刷新页面 切到network tab，找到需要修改的目标资源右键选择“save for overrides”，点击之后就会自动跳转到sources tab的overrides，在overrides中编辑资源即可，图片文件的替换可以直接在本地文件夹中操作 Chrome进入全屏模式后 隐藏工具栏（包含标签页tab、地址栏、书签） 方法1:“视图”菜单 -> 取消“在全屏模式下始终显示工具栏”勾选 方法2:“Shift + command + f”快捷键，重复这个操作可以 显示工具栏 "},"doc/Chrome/skills.html":{"url":"doc/Chrome/skills.html","title":"使用技巧","keywords":"","body":"Chrome 浏览器 Dev 94 开发者工具现已支持中文 Chrome 浏览器 Dev 94.0.4603.0 开发人员工具现已支持中文 具体设置方法 打开Chrome开发者工具 点击右上角“⚙️”图标进入到设置页面 左侧侧边栏选中“Preferences” 右侧main区域 “Appearance”大项 下的 “Language”小项，选择“Chinese - 中文”即可 常用插件 Header Editor 说明：管理浏览器请求，包括修改请求头和响应头、重定向请求、取消请求 使用场景：本地开发启动前端项目，页面有登录校验，登录成功后 前端发起ajax接口调用才能调通的场景 一般情况下在同浏览器窗口 新建标签页打开测试环境对应页面，只要本地启动的前端项目的域名（SwitchHosts中配置的host）包含测试环境对应页面域名即可共享同domian下的cookie 如果还不能调通，使用Header Editor添加一条规则，将测试环境成功登录后的cookie请求头信息配置到 本地前端项目域名下 "},"doc/DevTools/DevTools.html":{"url":"doc/DevTools/DevTools.html","title":"DevTools","keywords":"","body":"本地启动服务打开页面 http-server npm install http-server -g 在目标目录打开命令行 执行 \"http-server -p 自定义端口号\" npm源管理器 && node版本管理 npm源管理器：nrm 安装:sudo npm install -g nrm 查看是否安装成功:nrm --version❯ nrm --version 1.2.3 列出可选择的源:nrm ls 前面带 * 号的表示正在使用的源 ❯ nrm ls npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ *tencent ------ https://mirrors.cloud.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/ taobao ------- https://registry.nlark.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ 切换使用的源:nrm use npm❯ nrm use cnpm Registry has been set to: https://r.cnpmjs.org/ 删除一个源:nrm del \\ ❯ nrm del xdf delete registry xdf success 添加一个源:nrm add \\ \\ ❯ nrm add xdf http://npm.koolearn.com/ add registry xdf success 测试源速度:nrm test 测试一个源的响应时间：nrm test \\ ❯ nrm test npm npm ------ 1612ms 测试所有源的速度：nrm test ❯ nrm test npm ------ 1317ms yarn ----- 866ms tencent -- 316ms * cnpm ----- 572ms taobao --- 404ms npmMirror - 3440ms xdf ------ 957ms 访问源的主页：nrm home \\ node版本管理工具n 安装：sudo npm install -g n 查看是否安装成功:n --version❯ n --version v7.4.1 安装或使用一个node版本：sudo n node-version, 如果本地已存在这个node-version，则切换到这个node-version; 如果本地不存在这个node-version，则下载安装并切换❯ sudo n 8.12.0 installing : node-v8.12.0 mkdir : /usr/local/n/versions/node/8.12.0 fetch : https://nodejs.org/dist/v8.12.0/node-v8.12.0-darwin-x64.tar.xz installed : v8.12.0 (with npm 6.4.1 查看所有已经安装的node版本：n 使用或安装稳定的官方发布：sudo n stable❯ sudo n stable installing : node-v14.18.1 mkdir : /usr/local/n/versions/node/14.18.1 fetch : https://nodejs.org/dist/v14.18.1/node-v14.18.1-darwin-x64.tar.xz installed : v14.18.1 (with npm 6.14.15) 删除一个node版本：n rm node-version iTerm2配置 iTerm2 + oh-my-zsh + powerlevel10k 安装oh-my-zshcurl: export REMOTE=https://gitee.com/imirror/ohmyzsh.git sh -c \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)\" vim ~/.zshrc ZSH_THEME=\"agnoster\" vim简单使用 修改： i 保存并关闭： esc --> :wq 切换agnoster主题后会出现乱码，需要安装额外的字体 Meslo for Powerline，安装好后在 Preferences->Profiles->Text->Font中进行配置 和\"agnoster\"平级的，也可以安装powerlevel10k/powerlevel10k主题 手动克隆主题相关git仓库git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ~/powerlevel10k echo 'source ~/powerlevel10k/powerlevel10k.zsh-theme' >>~/.zshrc Set ZSH_THEME=\"powerlevel10k/powerlevel10k\" in ~/.zshrc 注意 2 3 4步操作后 需重启iTerm.app 方能看到效果 将iTerm2配置成 Visual Studio Code 的默认终端 打开iTerm2窗口，点击左上角菜单 iTerm2 --> Make iTerm2 Default Term 即可 注意：在vscode中使用配置了主题的 iTerm2，字体显示可能会不正常，解决方案： 打开iTerm2按住“command + ,”打开Preferences，在 Profiles --> Text --> Font 中查看当前使用的字体 打开vscode按住“shift + command + p”打开“命令面板”，检索“setting.json”，选择“Preferences： Open Setting（JSON）”，在JSON文件中追加字体配置，将下面json代码中的“Meslo LG S for Powerline”替换成你iTerm2使用的字体 即可\"editor.fontFamily\": \"Meslo LG S for Powerline\", \"terminal.integrated.fontFamily\": \"Meslo LG S for Powerline\" git相关 本地配置 查看git配置信息：git config --list 查看git用户名：git config user.name 查看邮箱配置：git config user.email 全局配置用户名：git config --global user.name \"nameVal\" 全局配置邮箱：git config --global user.email \"email@qq.com\"常用命令 // 删除本地分支 git branch -d localBrancheName || git branch --delete localBrancheName // 删除远程分支 git push origin -d remoteBranchName || git push origin --delete remoteBranchName git通过ssh连接github 本地生成ssh密钥（包含 私钥id_rsa 和 公钥id_rsa.pub） 终端中输入‘ssh-keygen -t rsa -C \"你的邮箱账号\"’ 注意：如果已经生成过 id_rsa 和 id_rsa.pub 的，可通过\"rm id_rsa\"和\"rm id_rsa.pub\"将密钥删除，生成的sshkey能用于多个代码托管平台 登入github，进入setting --> SSH and GPG keys --> New SSH key Title内容 随意，Key内容 对应公钥id_rsa.pub文件中的内容，然后点击“Add SSH key”保存 终端中输入 “ssh -T git@github.com”命令进行测试 emmet语法 简介：Emmet是一套面向文本编辑器的插件，它允许通过内容辅助高速度的编写和编辑HTML、CSS和其他结构化的代码格式，只要能安装他的编辑器都能使用，大部分编辑器都可以使用该语法规则,我们平时开发的Sublime Text、Eclipse、Notepad++、VS code、Atom、Dreamweaver等等编辑器都可以使用。 基本用法，更多语法详见Cheat Sheet 子节点 > li --> 兄弟节点 + 上级节点 ^ li>span^^div ^上一级，^^上两级 --> 倍增 * td*5 --> ID属性 # class属性 . 自定义属性 文本 {} 这是一篇markdown 组 () li>span)+div --> 数字序列 $ li.item$*10 --> Header 1 Header 2 Header 3 li.item$$*5 --> li.item$@-*3 倒序：@- --> li.item$@3*3 从n开始：@n --> HTML模版 ! --> tab Document "},"doc/Mac/Mac.html":{"url":"doc/Mac/Mac.html","title":"Mac","keywords":"","body":"给mac添加右键菜单“Open With VSCode” command + n 打开 “自动操作” 应用程序，点击“新建文稿” 选择快速操作 在左侧面板选择“实用工具”；然后找到”运行 Shell 脚本“后双击，在右侧“服务”收到选定选择文件夹，位置 “Finder（访达）.app”；“运行 Shell 脚本”的面板里，Shell选择 “/bin/bash“，传递输入选择 “作为自变量”，然后修改 Shell 脚本，如图![openWithVSCode][openWithVSCodePic] 按顺序操作，复制以下内容到 Shell 脚本中for f in \"$@\" do open -a \"Visual Studio Code\" \"$f\" done Command + s 保存为 「Open With VSCode」 小插曲：保存时报Operation not permitted，查资料后得知与Mac OS升级有关，解决方案如下 左上角点击选择‘系统偏好设置’ 选择“安全性与隐私” 选择 隐私-->“完全磁盘访问权限” 点击左下角按钮获得管理员操作权限 把出问题的应用程序加到““完全磁盘访问权限””列表中 好了，现在试试在 Finder 里右键一个文件，就可以直接看到「Open With VSCode」菜单，右键一个文件夹，就可以看到「服务」-「Open With VSCode」菜单了 Mac Finder中显示、隐藏 隐藏文件 “Shift + command + 。“ || “Shift + command + .“快捷键（即无需判断中英文输入法状态） "},"doc/Resume.html":{"url":"doc/Resume.html","title":"Resume","keywords":"","body":"田硕 男｜18601266033｜tsleader@aliyun.com｜天津籍 教育经历 2011-2015 江苏大学 本科 期望职位 Web前端开发工程师 专业技能 熟练掌握HTML5、CSS3及各类布局，像素级还原设计稿 熟练掌握JavaScript基本语法和ES6规范 熟练使用Vue2.0全家桶 熟悉Echarts、AntV等可视化工具 了解TypeScript、Webpack的基本使用 工作经历 时间 公司 岗位 2019.06-2021.08 北京红孩子互联科技有限公司 Web前端开发工程师 2017.07-2019.03 怡和祥云（北京）科技有限公司 Web前端开发工程师 备注：其中2019.04-2019.05这段时间去考取了摩托车驾照 项目经验 苏宁礼遇（包含H5、微信小程序、PC管理后台三端） 项目描述：苏宁大客户提供从企业采购基础产品到企业供应链全场景解决方案，为政府、企业提供行政物资、年节福利、渠道营销、工业品、地产精装配套等采购服务。前期参与了包括首页、商品四级页、热销排行榜、福利转赠、个人中心等多个页面的开发工作，后来独立负责H5项目的开发与版本迭代 H5 使用Vue + Webpack构建页面框架 使用flyio进行ajax请求 使用Vue-router管理路由，Vuex管理数据 封装公共组件、全局过滤器、自定义指令、工具类 使用mixin将多个组件的相同业务逻辑抽离 优化构建速度、优化产出代码 使用keep-alive对频繁切换展示隐藏的组件进行缓存 路由组件异步加载 bundle加hash 合理使用base64转化小图片 优化babel IgnorePlugin忽略特定模块 多进程打包、压缩js scope hoisting CDN 微信小程序 根据业务需求合理分包 二次封装wx.request，加入登陆拦截 抽离组件，精简单个复杂页面代码量 母账号后台管理页面 重构java ftl项目，实现前后端分离 使用Vue + TS + ElementUI搭建项目 使用axios进行ajax请求 使用Echarts实现各种饼图、柱状图、热力图等 专属商城（前后端未分离项目） 项目描述：苏宁旗下大客户企业采购专属平台。主要负责地址管理、订单管理、发票管理、常购清单等页面的开发 使用phpstudy_pro对前端代码进行启动服务、代理调试 灵活使用jQuery及validata.js、fileupload.js、daterangepicker.js等插件 页面响应速度调优 降低重排范围、减少重排次数 集中修改样式 DOM读写分离 DOM离线 使用position: absolute || fixed;脱离文档流 给瀑布流图片添加懒加载 输入框模糊查询、窗口resize页面scroll调用接口 做防抖、节流 给前端静态文件资源加时间戳，配合服务端做强制缓存、协商缓存 "}}