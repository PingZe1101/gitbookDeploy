{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 依赖安装 gitbook install 启动项目 gitbook serve 会在项目根目录下面生成 _book文件夹（里面是html静态文件）。并且启动了一个web服务器。 访问http://localhost:4000就可以看到效果 构建项目 gitbook build 会在mybook目录下面生成 _book文件夹（里面是html静态文件）。如果自己有web服务器，把_book文件夹复制到自己的服务器下面即可（首页是_book文件夹中的index.html） gitbook项目插件 gitbook项目添加、安装插件方式：book.json文件 在\"plugins\"中追加插件项，在\"pluginsConfig\"中进行配置 book.json plugins中追加插件项后 启动项目后会报错，命令行中执行\"gitbook install\"方可正常运行 错误信息：Error: Couldn't locate plugins ${插件名称}, Run 'gitbook install' to install plugins from registry. book.json中使用的插件 search-pro：高级搜索 anchor-navigation-ex-toc：为文章增加锚点目录栏及回到顶部功能 splitter：扩展导航侧边栏，支持宽度可调节 expandable-chapters-small：章节导航支持多层目录，并配置箭头图标，点击箭头才能实现收放目录 insert-logo：左侧导航栏上方插入Logo markdown语法 插入图片： 图片链接地址可以使用 base64 --> ![alt text][base64Variate]，base64Variate为定义在当前文件最下方的变量 值为图片对应的base64 文字链接：Title 插入图片，同时图片加链接： "},"doc/HTML/HTML.html":{"url":"doc/HTML/HTML.html","title":"HTML","keywords":"","body":"a标签 target属性常用值 _self：默认。在当前页面打开链接 _blank：在新窗口中打开链接 "},"doc/CSS/CSS.html":{"url":"doc/CSS/CSS.html","title":"CSS","keywords":"","body":"相邻兄弟选择器(Adjacent sibling selector) 适用场景：二者有相同的父元素，选择紧接在一个元素后的另一个元素 e.g. 给紧跟在 h1标签 后出现的 p标签 设置上外边距 h1 + p {margin-top:50px;} background复合属性写法 background: background-color background-image background-repeat background-attachment background-position/background-size; background-attachment scroll：背景图片随着页面的滚动而滚动（默认值） fixed：背景图片不会随着页面的滚动而滚动 background-position top center bottom left right，如果仅规定了一个关键词 第二个值将是“center” top left 和 left top 是一样的，都能够识别（已写demo验证） background-size cover：等比缩放背景图 以完全覆盖掉 背景区域 contain：在背景区域内完整地、最大化地展示 背景图（宽高等比缩放） percentage：将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为\"auto(自动)\" 背景区域非正方形的情况下： width > height: contain === 100% auto height > width: contain === auto 100% sass "},"doc/JavaScript/JavaScript.html":{"url":"doc/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript.md 数组方法 方法名 作用 返回值 是否修改原数组 备注 push 数组后增 数组length 是 unshift 数组前增 数组length 是 pop 数组后删 被删除的项 是 shift 数组前删 被删除的项 是 indexOf 寻找数组中某项对应的下标 Number(-1表示不包含目标项) 否 一般针对简单数据类型 findIndex 寻找数组中某项对应的下标 Number(-1表示不包含目标项) 否 一般针对引用类型 回调函数入参：(callback(Value[, Index[, Array]])[, thisArg])；thisArg 执行 callback 时用于 this 的值 find 寻找数组中第一个满足某条件的项 目标项 or undefined 否 同findIndex fitler 过滤数组中所有满足某条件的项 Array 否 同findIndex includes 判断数组中是否包含某项 Boolearn 否 some 判断数组中是否包含满足某条件的项 Boolearn 否 同findIndex every 判断数组中是否所有项都满足某条件 Boolearn 否 同findIndex map 根据需求格式化数组 Array 否 同findIndex forEach 单纯迭代 无 否 同findIndex concat 数组合并 Array 否 slice 数组截取 Array（由被截取项组成） 否 入参：([beginIndex[, endIndex]]) splice 数组截取并插入新项 Array（由被删除项组成） 是 (startIndex[, deleteCount[, item1[, item2[, ...]]]])；deleteCount为0时，新项就从start位置开始插入 reduce 数组累加器 可以是任意类型 否 使用说明 几点说明 入参为回调函数的几个方法，回调函数的入参相同 indexOf、findIndex、find、fitler、some、every、map、forEach：回调函数入参：(callback(Value[, Index[, Array]])[, thisArg])；thisArg 执行 callback 时用于 this 的值 针对 slice方法 的几点说明 该方法也可用于 String类型，返回值为 被截取项组成的String 如果省略 beginIndex，则 slice 从索引 0 开始 --> 数组的浅拷贝 截取部分不包含 endIndex 省略endIndex会截取到末尾；负数表示从末尾开始截取：-1表示最后一项，-2表示倒数第二项 封装insert方法Array.prototype.insert = function(index, item) { this.splice(index, 0, item); } "},"doc/JavaScript/DOM.html":{"url":"doc/JavaScript/DOM.html","title":"DOM","keywords":"","body":"event事件对象 event.target 和 event.currentTarget的区别 event.currentTarget 会返回当前触发事件元素，event.target会返回触发事件的源头元素 event.currentTarget 在控制台展开查看的时候已经不存在了。如果想拿到它，可以使用变量进行缓存，然后再进行操作 1 2 3 document.querySelector('.ok').addEventListener('click', function (event) { console.log('event', event); // 展开后发现 event.currentTarget 值为null console.log('event.currentTarget', event.currentTarget); // 值正常 }); addEventListener方法的第三个参数 给HTML元素绑定事件有下面三种方法，以最常见的“click”事件为例 直接在对应的HTML元素标签上绑定函数，违反了HTML与JavaScript分离的准则，不推荐 Click Me! 在JS代码中指定元素的“onclick”方法，只能给一个事件绑定一个响应函数，重复绑定会覆盖之前的绑定 var btn = document.getElementById(\"submit\"); btn.onclick = onClickFn; 使用事件监听“addEventListener”绑定方法，可以绑定多个不同的函数，不会覆盖，推荐 var btn = document.getElementById(\"submit\"); btn.addEventListener(\"click\", onClickFn, false); 第三种方法“addEventListener”中的第三个参数是用来控制什么的呢 事件捕获 和 事件冒泡 还是以最常见的“click”事件为例，页面中标签由里到外层层嵌套 结构如同洋葱，当鼠标点击所看到的的按钮时，其实发生了一系列的事件传递：button实际上是被body“包裹”起来的，body是被html“包裹”起来的，html又是被document“包裹”起来的，document是被window“包裹”起来的。所以，在点击鼠标的时候，最先获得这个点击的是最外面的window，然后经过一系列传递 才会传到最后的目标button，当传到button的时候，这个事件又会像水底的泡泡一样慢慢往外层穿出，直到window结束。 综上，一个事件的传递过程包含三个阶段，分别为： 捕获阶段 目标阶段 冒泡阶段 说明： 事件的传递过程为：捕获阶段 --> 目标阶段 --> 冒泡阶段，对应的event.eventPhase分别为 1 --> 2 --> 3，很好记 目标阶段指的就是 包裹得最深的那个元素 “addEventListener”第三个参数是用来控制事件处理程序 事件捕获时触发 or 事件冒泡时触发 addEventListener的第三个参数设置为true和false的区别 true表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件； false表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件 第三个参数默认为false` Click Me! var div = document.getElementById('d'); var p = document.getElementById('p'); var span = document.getElementById('s'); function onClickFn (event) { var tagName = event.currentTarget.tagName; var phase = event.eventPhase; // event.eventPhase 事件传播的当前阶段，1 捕获阶段，2 目标阶段， 3 冒泡阶段 console.log(tagName, phase); } 1. 分别给三个元素添加事件监听，第三个参数设置为false，点击“Click Me!”： ```javascript div.addEventListener('click', onClickFn, false); p.addEventListener('click', onClickFn, false); span.addEventListener('click', onClickFn, false); // SPAN 2 // P 3 // DIV 3 ``` 1. p和div都是在冒泡阶段响应了事件，由于冒泡的特性，裹在最里层的span率先做出响应 2. addEventListener第三个参数设置为true，点击“Click Me!”： ```javascript div.addEventListener('click', onClickFn, false); p.addEventListener('click', onClickFn, false); span.addEventListener('click', onClickFn, false); DIV 1 P 1 SPAN 2 ``` 在冒泡阶段，如果不希望事件继续往上传播，例如，冒泡到p的时候就停止传播，那么，可以在p的事件回调函数里面添加“event.stopPropagation” "},"doc/CodeSegment/CodeSegment.html":{"url":"doc/CodeSegment/CodeSegment.html","title":"CodeSegment","keywords":"","body":"css 删除a标签默认样式 a { text-decoration: none; color: #333; // 值为设计稿 目标样式 } 文字单行超出省略号儿 overflow: hidden; //超出的文本隐藏 text-overflow: ellipsis; //溢出用省略号显示 white-space: nowrap; //溢出不换行 文字n行超出省略号儿 overflow: hidden; text-overflow: ellipsis; display: -webkit-box; // 作为弹性伸缩盒子模型显示。 -webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列 -webkit-line-clamp: n; // n为显示的行数 js 阻止默认事件 Event.preventDefault();阻止事件冒泡 Event.stopPropagation(); 另 Event.cancelBubble = true; // MDN解释 Event.cancelBubble 属性是 Event.stopPropagation()的一个曾用名，查询网络得知其存在的意义在于 为兼容IE，都快2022年了 还有几个用IE的，阻止事件冒泡尽管用 Event.stopPropagation() 就完了阻止事件冒泡、同时阻止监听同一事件的其他事件监听器被调用 Event.stopImmediatePropagation(); 如果多个事件监听器被附加到相同元素的相同事件类型上，当此事件触发时，它们会按其被添加的顺序被调用。如果在其中一个事件监听器中执行 stopImmediatePropagation() ，那么剩下的事件监听器都不会被调用 paragraph const p = document.querySelector('p') p.addEventListener(\"click\", (event) => { alert(\"我是p元素上被绑定的第一个监听函数\"); }, false); p.addEventListener(\"click\", (event) => { alert(\"我是p元素上被绑定的第二个监听函数\"); event.stopImmediatePropagation(); // 执行stopImmediatePropagation方法，阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行 }, false); p.addEventListener(\"click\",(event) => { alert(\"我是p元素上被绑定的第三个监听函数\"); // 该监听函数排在上个函数后面，该函数不会被执行 }, false); document.querySelector(\"div\").addEventListener(\"click\", (event) => { alert(\"我是div元素,我是p元素的上层元素\"); // p元素的click事件没有向上冒泡，该函数不会被执行 }, false); 禁止蒙层底部页面跟随滚动的方法（pc、h5全平台兼容） function preventBodyScroll (isFixed) { const winScrollY = window.scrollY; const bodyEle = document.body; if (isFixed) { bodyEle.style.position = 'fixed' bodyEle.style.top = `-${winScrollY}px`; } else { bodyEle.style.position = ''; bodyEle.style.top = ''; window.scrollTo(0, winScrollY); // 回到原先的top } } 获取数组中某项的索引，indexOf Polyfill !Array.prototype.indexOf && Array.prototype.indexOf = function(item) { for(var i = 0; i 获取url query参数值 function getSearchParams() { const { search } = window.location; if (!search) return ''; return search .slice(1) .split('&') .map((group) => group.split('=')) .reduce((searchParamsObj, item) => { searchParamsObj[item[0]] = item[1]; return searchParamsObj; }, {}); } 扩展运算符 合并对象 合并对象1 const obj1 = { name: 'xiaohei', age: 12, eat: 'fruit', } const obj2 = { ...obj1, color: 'black', } const {eat, ...targetObj} = obj2; // 注意前面的const console.log(targetObj); /* { name: 'xiaohei', age: 12, color: 'black', } */ 合并对象1 // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(''); } // good function concatenateAll(...args) { return args.join(''); } 将类数组转换为数组 function fn(){return arguments}; const arrayLike = fn('a', 'b', 'c', 'd'); console.log(Object.prototype.toString.call(arrayLike)); // [object Arguments] const arr1 = Array.prototype.slice.call(arrayLike); console.log(Object.prototype.toString.call(arr1)); // [object Array] const arr2 = [...arrayLike]; console.log(Object.prototype.toString.call(arr2)); // [object Array] 解构 Destructuring 对象解构 // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`; } // good function getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`; } // best function getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`; } 数组解构 const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; 获取图片宽高（较优解） const img = new Image(); img.src = \"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2020-04-07%2F5e8c1c1f397b9.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641609272&t=8166b79fc50ddaf648982d4171ad040f\"; // 图片来源于 百度图片 const check = function() { if (img.width || img.height) { // TODO clearInterval(interval); } } const interval = setInterval(check, 10); 日期转化为 时间戳 var now = new Date(); console.log('Date.getTime()', now.getTime()); // Date.getTime() 1639989558558 console.log('Date.valueOf()', now.valueOf()); // Date.valueOf() 1639989558558 console.log('+ Date', + now); // + Date 1639989558558 console.log('Date.parse()', Date.parse(now)); // Date.parse() 1639989558000 console.log('new Date(1639989558558)', new Date(1639989558558)); // new Date(1639989558558) Mon Dec 20 2021 16:39:18 GMT+0800 (中国标准时间) console.log('new Date(1639989558000)', new Date(1639989558000)); // new Date(1639989558000) Mon Dec 20 2021 16:39:18 GMT+0800 (中国标准时间) // 补充：获取 当前时间戳 的快捷方式：Date.now(); 这里是 Date对象的 now方法，不是上面的 now 变量哈 注： 以上运行结果来源于 Chrome 版本 96.0.4664.110（正式版本） (x86_64)，Date.parse()方法陈独秀 比其他几种方法得出来的结果早了 558ms 规避问题方案：在代码中多个转化后的时间戳进行比较操作时 注意使用一致的方法 判断当前时间是否是当天 function isCurrentDay(targetTimeStamp){ const startTimeStamp = new Date().setHours(0, 0, 0, 0); // dateObj.setHours(hoursValue[, minutesValue[, secondsValue[, msValue]]]); 返回 日期对象实例所表示时间的毫秒数 const endTimeStamp = new Date().setHours(23, 59, 59, 999); return startTimeStamp 动态插入js // 动态异步引入js function createScript(src) { var scriptEle = document.createElement(\"script\"); scriptEle.src = src; scriptEle.async = false; // 此行代码作用：1、js是被异步加载的；2、同时引入多个js（函数被调用多次）执行脚本的顺序 将与 代码中的书写顺序 保持一致，不受加载快慢影响 document.querySelector(\"body\").appendChild(scriptEle); } createScript(targetScriptSrc); // 动态同步引入js function loadAsyncScript(src, callback = function() {}) { var scriptEle = document.createElement(\"script\"); scriptEle.src = src; scriptEle.async = false; // 此行代码作用：1、js是被异步加载的；2、同时引入多个js（函数被调用多次）执行脚本的顺序 将与 代码中的书写顺序 保持一致，不受加载快慢影响 document.querySelector(\"body\").appendChild(scriptEle); scriptEle.onload = function() { // script标签的onload事件 是在外部js文件被加载完成并执行完成后才被触发的 callback(); } } loadAsyncScript(targetScriptSrc, callback); 背景：JS 可能会操作DOM（修改 DOM结构 || 样式），因此 JS 的执行过程 不能和 HTML||CSS 的下载||执行过程 并行，自上到下解析HTML的过程中 若碰到需顺序加载的外联 JS，会暂时中止 HTML 的解析流程，等候脚本下载和解析执行完成后再继续 进行之前中断掉的 HTML 解析流程，这就导致了 script 标签外联 JS 加载存在一些缺陷：会影响整个页面效率，一旦网速不好整个网站将等待 JS 加载 而不进行后续渲染，由于中断了 HTML 解析流程，导致页面空白，影响体验，以前的写法是将 script 标签写在 body 最后面，等 DOM 全部解析完成后才加载 JS，HTML5 标准有另一套异步加载 JS 的方法：defer 和 async 属性 script标签加上defer、async两个之中的任意属性之后,在js真正执行之前都不会阻止html的加载 defer defer=“defer” 或直接写 defer 就可以让这个 script 外联的 JS 变成异步加载 HTML 解析流程中若碰到外联 JS，会开辟新线程来下载脚本，下载完成后不会立即解析，不会阻塞 HTML 的解析流，等到 HTML 解析完毕后（不包括下载完里面的资源），再进行脚本的执行解析 该方法只有 IE 和一些高版本的 firefox 和 chrome 可以用，当前看（20211223）比较少被使用 这种方式可以在 script 标签里面写代码 注意：IE6 和 IE7 的异步加载最多只能有 2 个，超过两个时必须等前两个加载完才会加载第三个 理论上，添加 defer 属性后 可以保证顺序执行。但实际 却发现顺序也不能确定。在JavaScript高级程序设计(第3版)中有这么一句： 在现实当中，延迟脚本不一定按顺序执行，也不一定会在DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本 async async 是 asynchronous（异步） 的缩写，是 HTML5 标准 HTML 解析流程中若碰到外联 JS，会开辟新线程来下载脚本，下载完成后立即解析执行，且解析流程会中断 HTML 解析流程，等到脚本执行完成后才会继续进行之前中断掉的 HTML 解析流程 该属性除了 IE6 ～ IE8 其他的浏览器都好用，相对defer使用更广泛些 该方式不能把代码写在 script 标签里，只能引用外部脚本（虽然标准是这么写的，但现在随着内核升级 async 的 script 标签里也可以写代码（即在没有 src 情况下）） 设置了 async=true 的 JS 代码不能保证是顺序执行的，按照 race 的方式哪个脚本先下载完就先解析哪个脚本 可以通过设置 async=false以保证代码执行顺序 与 代码书写顺序 保持一致（即使下面的脚本相比上面的脚本 被先加载到本地） 注： 设置async=false，脚本仍然会异步加载 async=false 与 不写async完全是两种情况： 静态引入的script如果不设置 async 那脚本压根就不会异步加载 动态引入的script async默认值为true defer 和 async 这两个属性不能一起使用 结： defer || async属性都能实现 js脚本 的异步加载，defer是 等HTML解析完毕后 才进行js解析；async在脚本异步加载完成后 就进行js解析 js是单线程的，解析js会中断 HTML解析 补充：script标签onload事件：script标签的onload事件 是在外部js文件被加载完成并执行完成后才被触发的 "},"doc/Chrome/Chrome.html":{"url":"doc/Chrome/Chrome.html","title":"Chrome","keywords":"","body":"Chrome65+ local overrides 介绍：通过overrides可以在浏览器中直接修改一些请求的返回数据，类似于使用fiddler代理抓包重写返回数据一样 用途：调试线上（pre || prd）页面接口返回的静态资源（html、css、js、图片） 使用方法： 打开开发者工具的sources页，找到overrides tab 点击“Select folder for overrides”按钮选择本地文件夹 勾选“Enable local overrides” 注：勾选状态下 如果选择的本地文件夹不为空，network tab处会出现一个黄色的三角形提示；如果文件夹中的 文件夹路径、文件名 与 network中x请求全等，则x请求的返回结果就会被立即重写 刷新页面 切到network tab，找到需要修改的目标资源右键选择“save for overrides”，点击之后就会自动跳转到sources tab的overrides，在overrides中编辑资源即可，图片文件的替换可以直接在本地文件夹中操作 Chrome进入全屏模式后 隐藏工具栏（包含标签页tab、地址栏、书签） 方法1:“视图”菜单 -> 取消“在全屏模式下始终显示工具栏”勾选 方法2:“Shift + command + f”快捷键，重复这个操作可以 显示工具栏 开发者工具的移动设备仿真器打开||关闭 手机||平板电脑外观图形 三点菜单允许你显示或隐藏其他设置，切换\"Show||Hide device frame\"(设备边框,如果可用，手机或平板电脑的外观图形） Chrome（版本 96.0.4664.110（正式版本） (x86_64)） 开发者工具 -> Network 接口请求中的 Payload 放到了单独的tab，之前是在 Headers tab中 "},"doc/Chrome/skills.html":{"url":"doc/Chrome/skills.html","title":"使用技巧","keywords":"","body":"Chrome 浏览器 Dev 94 开发者工具现已支持中文 Chrome 浏览器 Dev 94.0.4603.0 开发人员工具现已支持中文 具体设置方法 打开Chrome开发者工具 点击右上角“⚙️”图标进入到设置页面 左侧侧边栏选中“Preferences” 右侧main区域 “Appearance”大项 下的 “Language”小项，选择“Chinese - 中文”即可 常用插件 Header Editor 说明：管理浏览器请求，包括修改请求头和响应头、重定向请求、取消请求 使用场景：本地开发启动前端项目，页面有登录校验，登录成功后 前端发起ajax接口调用才能调通的场景 一般情况下在同浏览器窗口 新建标签页打开测试环境对应页面，只要本地启动的前端项目的域名（SwitchHosts中配置的host）包含测试环境对应页面域名即可共享同domian下的cookie 如果还不能调通，使用Header Editor添加一条规则，将测试环境成功登录后的cookie请求头信息配置到 本地前端项目域名下 "},"doc/DevTools/DevTools.html":{"url":"doc/DevTools/DevTools.html","title":"DevTools","keywords":"","body":"本地启动服务打开页面 http-server npm install http-server -g 在目标目录打开命令行 执行 \"http-server -p 自定义端口号\" npm源管理器 && node版本管理 npm源管理器：nrm 安装:sudo npm install -g nrm 查看是否安装成功:nrm --version❯ nrm --version 1.2.3 列出可选择的源:nrm ls 前面带 * 号的表示正在使用的源 ❯ nrm ls npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ *tencent ------ https://mirrors.cloud.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/ taobao ------- https://registry.nlark.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ 切换使用的源:nrm use npm❯ nrm use cnpm Registry has been set to: https://r.cnpmjs.org/ 删除一个源:nrm del \\ ❯ nrm del xdf delete registry xdf success 添加一个源:nrm add \\ \\ ❯ nrm add xdf http://npm.koolearn.com/ add registry xdf success 测试源速度:nrm test 测试一个源的响应时间：nrm test \\ ❯ nrm test npm npm ------ 1612ms 测试所有源的速度：nrm test ❯ nrm test npm ------ 1317ms yarn ----- 866ms tencent -- 316ms * cnpm ----- 572ms taobao --- 404ms npmMirror - 3440ms xdf ------ 957ms 访问源的主页：nrm home \\ node版本管理工具n 安装：sudo npm install -g n 查看是否安装成功:n --version❯ n --version v7.4.1 安装或使用一个node版本：sudo n node-version, 如果本地已存在这个node-version，则切换到这个node-version; 如果本地不存在这个node-version，则下载安装并切换❯ sudo n 8.12.0 installing : node-v8.12.0 mkdir : /usr/local/n/versions/node/8.12.0 fetch : https://nodejs.org/dist/v8.12.0/node-v8.12.0-darwin-x64.tar.xz installed : v8.12.0 (with npm 6.4.1 查看所有已经安装的node版本：n 使用或安装稳定的官方发布：sudo n stable❯ sudo n stable installing : node-v14.18.1 mkdir : /usr/local/n/versions/node/14.18.1 fetch : https://nodejs.org/dist/v14.18.1/node-v14.18.1-darwin-x64.tar.xz installed : v14.18.1 (with npm 6.14.15) 删除一个node版本：n rm node-version iTerm2配置 iTerm2 + oh-my-zsh + powerlevel10k 安装oh-my-zshcurl: export REMOTE=https://gitee.com/imirror/ohmyzsh.git sh -c \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)\" vim ~/.zshrc ZSH_THEME=\"agnoster\" vim简单使用 修改： i 保存并关闭： esc --> :wq 切换agnoster主题后会出现乱码，需要安装额外的字体 Meslo for Powerline，安装好后在 Preferences->Profiles->Text->Font中进行配置 和\"agnoster\"平级的，也可以安装powerlevel10k/powerlevel10k主题 手动克隆主题相关git仓库git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ~/powerlevel10k echo 'source ~/powerlevel10k/powerlevel10k.zsh-theme' >>~/.zshrc Set ZSH_THEME=\"powerlevel10k/powerlevel10k\" in ~/.zshrc 注意 2 3 4步操作后 需重启iTerm.app 方能看到效果 将iTerm2配置成 Visual Studio Code 的默认终端 打开iTerm2窗口，点击左上角菜单 iTerm2 --> Make iTerm2 Default Term 即可 注意：在vscode中使用配置了主题的 iTerm2，字体显示可能会不正常，解决方案： 打开iTerm2按住“command + ,”打开Preferences，在 Profiles --> Text --> Font 中查看当前使用的字体 打开vscode按住“shift + command + p”打开“命令面板”，检索“setting.json”，选择“Preferences： Open Setting（JSON）”，在JSON文件中追加字体配置，将下面json代码中的“Meslo LG S for Powerline”替换成你iTerm2使用的字体 即可\"editor.fontFamily\": \"Meslo LG S for Powerline\", \"terminal.integrated.fontFamily\": \"Meslo LG S for Powerline\" 窗口基本使用（与Chrome基本相同） 打开新窗口：command+n 打开新标签页（tab）：command+t 关闭当前标签页：command+w 多个标签页切换：control+Tab 在终端（iTerm2 || Mac自带Terminal 都适用）中通过 命令的方式打开 文件夹 在 Finder 中显示 在终端中cd到 目标文件夹名 的根目录 使用“open 目标文件夹名“命令 使用 Visual Studio Code 打开 在 Visual Studio Code 中安装“code”命令 打开VSCode command+shift+p –> 输入shell command –> 点击提示Shell Command: Install ‘code’ command in PATH 输入shell command时可以同步看到“Shell Command: Uninstall ‘code’ command in PATH”，点击可卸载“code”命令 在终端中cd到 目标文件夹名 的根目录 使用“code 目标文件夹名“命令 git相关 本地配置 查看git配置信息：git config --list 查看git用户名：git config user.name 查看邮箱配置：git config user.email 全局配置用户名：git config --global user.name \"nameVal\" 全局配置邮箱：git config --global user.email \"email@qq.com\"常用命令 ```git // 查看所有远程分支 git branch -a // 检出远程分支到本地 // 一般localBrancheName 与 remoteBranchName 同名，如果目标远程分支 本地pull不到，那checkout会失败 git checkout -b localBrancheName remoteBranchName // vscode pull不到远程新建分支，使用此命令 git remote update origin 存疑：网上看git fetch也可以解决这个问题，git fetch干什么用的 // 删除本地分支 git branch -d localBrancheName || git branch --delete localBrancheName // 删除远程分支 git push origin -d remoteBranchName || git push origin --delete remoteBranchName // git commit后想要撤回commit git reset --mixed HEAD^ // 不删除工作空间改动代码，撤销最近一次commit，并且撤销git add. git reset --soft HEAD^ // 不删除工作空间改动代码，撤销最近一次commit，不撤销git add. git reset --hard HEAD^ // 删除工作空间改动代码，撤销最近一次commit，撤销git add. // HEAD^意思是上一个版本，也可以写成HEAD~1，如果你进行了2次commit，想都撤回，可以使用HEAD~2 // git commit后想修改message git commit amend // 然后通过vim修改即可：键入“i”进入INSERT修改模式，修改完成后点击“esc”再键入“:wq会车”即可 ### .gitignore 1. 简介：每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些 文件||文件夹 是不需要被添加到版本管理中的。比如这个基于gitbook框架的项目：根目录下的node_modules 和 _book 文件夹，这些不需要提那家到版本管理中的 文件||文件夹 在项目中很重要，但是它们占用内存也是很大的，所以一般我们使用Git管理的时候 会将其添加到.gitignore文件中 2. 常用规则 /mtk/ 过滤根目录下的mtk文件夹 包含里面的所有文件 *.zip 过滤所有.zip文件 /mtk/do.c 过滤根目录下的mtk文件夹中的do.c文件 ``` - 通过以上规则的配置：被过滤掉的文件就不会出现在你的Git仓库中了，当然本地库中还有，只是push的时候不会上传 除了以上规则，它还可以指定要将哪些文件添加到版本管理中（include 和 exclude 的区别） ``` !src/ 不过滤该文件夹 !*.zip 不过滤所有.zip文件 !/mtk/do.c 不过滤该文件 ``` 配置语法： 以斜杠/开头表示目录； 以星号*通配多个字符； 以问号?通配单个字符 以方括号[]包含单个字符的匹配列表； 以叹号!表示不忽略(跟踪)匹配到的文件或目录； 此外，git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； 示例说明 规则：fd1/* 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； 规则：/fd1/* 说明：忽略根目录下的 /fd1/ 目录的全部内容； 规则：/* !.gitignore !/fw/bin/ !/fw/sf/ 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录 创建.gitignore文件 常规的windows操作（windows下不允许在资源管理器中直接新建 匿名文件，所以先新建“gitignore.txt”文件） 项目根目录下创建gitignore.txt； 编辑gitignore.txt，写下你的规则，例如加上node_modules/； 打开命令行窗口，切换到 项目根目录； 执行命令ren gitignore.txt .gitignore ren 即 “rename” 用Git Bash 根目录下右键选择“Git Bash Here”进入bash命令窗口； 输入vim .gitignore 或 touch .gitignore命令，打开文件（没有文件会自动创建）； 按i键切换到编辑状态，输入规则，例如node_modules/，然后按Esc键退出编辑，输入:wq保存退出git通过ssh连接github 本地生成ssh密钥（包含 私钥id_rsa 和 公钥id_rsa.pub） 终端中输入‘ssh-keygen -t rsa -C \"你的邮箱账号\"’ 注意：如果已经生成过 id_rsa 和 id_rsa.pub 的，可通过\"rm id_rsa\"和\"rm id_rsa.pub\"将密钥删除，生成的sshkey能用于多个代码托管平台 登入github，进入setting --> SSH and GPG keys --> New SSH key Title内容 随意，Key内容 对应公钥id_rsa.pub文件中的内容，然后点击“Add SSH key”保存 终端中输入 “ssh -T git@github.com”命令进行测试 emmet语法 简介：Emmet是一套面向文本编辑器的插件，它允许通过内容辅助高速度的编写和编辑HTML、CSS和其他结构化的代码格式，只要能安装他的编辑器都能使用，大部分编辑器都可以使用该语法规则,我们平时开发的Sublime Text、Eclipse、Notepad++、VS code、Atom、Dreamweaver等等编辑器都可以使用。 基本用法，更多语法详见Cheat Sheet 子节点 > li --> 兄弟节点 + 上级节点 ^ li>span^^div ^上一级，^^上两级 --> 倍增 * td*5 --> ID属性 # class属性 . 自定义属性 文本 {} 这是一篇markdown 组 () li>span)+div --> 数字序列 $ li.item$*10 --> Header 1 Header 2 Header 3 li.item$$*5 --> li.item$@-*3 倒序：@- --> li.item$@3*3 从n开始：@n --> HTML模版 ! --> tab Document Chrome inspect调试 Android 微信X5内核 H5页面 调研背景：H5页面在 微信环境中打开 与 在其他宿主环境（手机浏览器、PC端手机模拟器）中打开 展示样式不一致 微信X5内核：该内核是腾讯的浏览服务，是用来帮助应用开发商大幅改善应用体验，有效提升开发，运营，商业化效率的，但是，被用户反馈视频兼容性不好，打开速度慢，没有夜间模式等等问题。通过关闭微信X5内核，使用系统内部原生WebView，可以提升整体速度和使用体验 微信X5内核 && 手机USB调试模式 && PC chrome://inspect 调试微信端打开的H5页面 微信X5内核（如遇链接打不开 转化成二维码使用微信扫一扫再试） 如何查看你的微信X5内核是否被启用 打开一篇公众号文章或者一个微信内部网页，在页面内的顶部往下拉，如果看到“QQ浏览器X5内核提供技术支持”这一行字样，说明你正在使用微信X5内核 启用 微信X5内核（链接均为 在微信环境打开） http://debugmm.qq.com/?forcex5=ture 注：启用微信X5内核 只针对Android端 微信App，IOS端 微信App 访问此链接为空白页 关闭 微信X5内核 http://debugmm.qq.com/?forcex5=false 已启用 微信X5内核的情况下，打开 tbs调试页面 http://debugtbs.qq.com 点击“DebugX5”进入“X5 调试页面”，进入信息tab 打开下图中三项调试功能 如果暂未启用 || 已关闭 微信X5内核，访问 http://debugtbs.qq.com 后会跳转至 错误信息页面 注：打开tbs调试页面 只针对Android端 微信App，IOS端 微信App 访问此链接为 错误提示页 开启手机USB调试模式（20211217 以Android终端红米K40为例） 设置 --> 我的设备 --> 全部参数 --> 连击“MIUI版本” 会有toast提示框 提示“开发者模式”是否打开，“开发者模式”被打开后 设置 --> 更多设置 --> 开发者模式 --> 往下滑找到调试tab，打开“USB 调试” && “USB调试（安全设置）” PC（20211217 以MacBook Pro macOS Big Sur为例） chrome://inspect 调试微信访问的 H5页面 PC端 使用chrome访问“chrome://inspect” 线缆链接手机 和 PC 坑点：使用手机充电线缆进行连接（usb端连接至mac扩展坞），连接状态及不稳定 解决方案：使用mac充电线（ 双端type c的线）链接即可（红米K40充电口为 type c接口） 在手机微信中打开 目标h5链接，在inspect页面 Devices选项中，就会出现微信WebView页面了，然后点击 需要调试页面 下面的inspect按钮，及可进行调试 扩展：调试 在 Android Chrome App中 打开的h5页面： Android Chrome App && 手机USB调试模式 && PC chrome://inspect Chrome App无需特别设置，手机USB调试模式、PC chrome://inspect 与 上面相同 注： 如果点击“inspect”后出现的页面是个空白页，上面显示“HTTP/1.1 404 Not Found”，PC Chrome进正向代理翻墙即可 IOS端H5页面调试 暂时没用到，后续碰到了再研究 "},"doc/Mac/Mac.html":{"url":"doc/Mac/Mac.html","title":"Mac","keywords":"","body":"给mac添加右键菜单“Open With VSCode” command + n 打开 “自动操作” 应用程序，点击“新建文稿” 选择快速操作 在左侧面板选择“实用工具”；然后找到”运行 Shell 脚本“后双击，在右侧“服务”收到选定选择文件夹，位置 “Finder（访达）.app”；“运行 Shell 脚本”的面板里，Shell选择 “/bin/bash“，传递输入选择 “作为自变量”，然后修改 Shell 脚本，如图![openWithVSCode][openWithVSCodePic] 按顺序操作，复制以下内容到 Shell 脚本中for f in \"$@\" do open -a \"Visual Studio Code\" \"$f\" done Command + s 保存为 「Open With VSCode」 小插曲：保存时报Operation not permitted，查资料后得知与Mac OS升级有关，解决方案如下 左上角点击选择‘系统偏好设置’ 选择“安全性与隐私” 选择 隐私-->“完全磁盘访问权限” 点击左下角按钮获得管理员操作权限 把出问题的应用程序加到““完全磁盘访问权限””列表中 好了，现在试试在 Finder 里右键一个文件，就可以直接看到「Open With VSCode」菜单，右键一个文件夹，就可以看到「服务」-「Open With VSCode」菜单了 Mac Finder中显示、隐藏 隐藏文件 “Shift + command + 。“ || “Shift + command + .“快捷键（即无需判断中英文输入法状态） 安装非信任开发者的软件后，通过“command + space”打开，系统提示“无法打开xxx，因为无法验证开发者”，且dialog底部不包含“打开”选项 解决方案 打开Finder，左侧选中“应用程序”，在对应右侧列表中找到 目标应用程序 右键点击打开，发现dialog底部多了“打开”选项 "},"doc/Resume.html":{"url":"doc/Resume.html","title":"Resume","keywords":"","body":"田硕 男｜18601266033｜tsleader@aliyun.com｜天津籍 教育经历 2011-2015 江苏大学 本科 期望职位 Web前端开发工程师 专业技能 熟练掌握HTML5、CSS3及各类布局，像素级还原设计稿 熟练掌握JavaScript基本语法和ES6规范 熟练使用Vue2.0全家桶 熟悉Echarts、AntV等可视化工具 了解TypeScript、Webpack的基本使用 工作经历 时间 公司 岗位 2019.06-2021.08 北京红孩子互联科技有限公司 Web前端开发工程师 2017.07-2019.03 怡和祥云（北京）科技有限公司 Web前端开发工程师 备注：其中2019.04-2019.05这段时间去考取了摩托车驾照 项目经验 苏宁礼遇（包含H5、微信小程序、PC管理后台三端） 项目描述：苏宁大客户提供从企业采购基础产品到企业供应链全场景解决方案，为政府、企业提供行政物资、年节福利、渠道营销、工业品、地产精装配套等采购服务。前期参与了包括首页、商品四级页、热销排行榜、福利转赠、个人中心等多个页面的开发工作，后来独立负责H5项目的开发与版本迭代 H5 使用Vue + Webpack构建页面框架 使用flyio进行ajax请求 使用Vue-router管理路由，Vuex管理数据 封装公共组件、全局过滤器、自定义指令、工具类 使用mixin将多个组件的相同业务逻辑抽离 优化构建速度、优化产出代码 使用keep-alive对频繁切换展示隐藏的组件进行缓存 路由组件异步加载 bundle加hash 合理使用base64转化小图片 优化babel IgnorePlugin忽略特定模块 多进程打包、压缩js scope hoisting CDN 微信小程序 根据业务需求合理分包 二次封装wx.request，加入登陆拦截 抽离组件，精简单个复杂页面代码量 母账号后台管理页面 重构java ftl项目，实现前后端分离 使用Vue + TS + ElementUI搭建项目 使用axios进行ajax请求 使用Echarts实现各种饼图、柱状图、热力图等 专属商城（前后端未分离项目） 项目描述：苏宁旗下大客户企业采购专属平台。主要负责地址管理、订单管理、发票管理、常购清单等页面的开发 使用phpstudy_pro对前端代码进行启动服务、代理调试 灵活使用jQuery及validata.js、fileupload.js、daterangepicker.js等插件 页面响应速度调优 降低重排范围、减少重排次数 集中修改样式 DOM读写分离 DOM离线 使用position: absolute || fixed;脱离文档流 给瀑布流图片添加懒加载 输入框模糊查询、窗口resize页面scroll调用接口 做防抖、节流 给前端静态文件资源加时间戳，配合服务端做强制缓存、协商缓存 "}}