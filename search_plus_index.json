{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 依赖安装 gitbook install 启动项目 gitbook serve 会在项目根目录下面生成 _book文件夹（里面是html静态文件）。并且启动了一个web服务器。 访问http://localhost:4000就可以看到效果 构建项目 gitbook build 会在mybook目录下面生成 _book文件夹（里面是html静态文件）。如果自己有web服务器，把_book文件夹复制到自己的服务器下面即可（首页是_book文件夹中的index.html） 碰到过“Error with plugin \"anchor-navigation-ex-toc\": Cannot find module 'cheerio'”报错，rimraf node_modules、重新安装依赖后再试 部署项目 在 master分支 回合 dev分支代码 在 master分支 终端中执行 \"gitbook build\" 进行构建，将构建好的 _book文件夹 push到远程 执行 “git subtree push --prefix _book origin release” 将 _book文件夹 推送到 release分支 切换到 release分支，执行 “git push github release:master” 将 origin relase分支的代码 push到 github仓库的master分支（为不暴露origin中的源码，将构建后的文件 存放到github单独的仓库中进行部署） 第一次操作需添加 github仓库，执行：git remote add github \"git@github.com:PingZe1101/gitbookDeploy.git\" 另：补充 Vue官网提供的部署脚本 gitbook项目插件 gitbook项目添加、安装插件方式：book.json文件 在\"plugins\"中追加插件项，在\"pluginsConfig\"中进行配置 book.json plugins中追加插件项后 启动项目后会报错，命令行中执行\"gitbook install\"方可正常运行 错误信息：Error: Couldn't locate plugins ${插件名称}, Run 'gitbook install' to install plugins from registry. book.json中使用的插件 search-pro：高级搜索 anchor-navigation-ex-toc：为文章增加锚点目录栏及回到顶部功能 splitter：扩展导航侧边栏，支持宽度可调节 expandable-chapters-small：章节导航支持多层目录，并配置箭头图标，点击箭头才能实现收放目录 insert-logo：左侧导航栏上方插入Logo markdown语法 vscode中写md，发现有序列表、无序列表 回车换行后未自动带出 序号，给vscode（不是本gitbook项目）安装 “MarkDown All in One” 插件即可 插入图片：![alt text](http://path/to/img.jpg) 图片链接地址可以使用 base64 --> ![alt text][base64Variate]，base64Variate为定义在当前文件最下方的变量 值为图片对应的base64 文字链接：[Title](超链地址) 插入图片，同时图片加链接：[![alt text](http://path/to/img.jpg)](超链地址) 单行代码使用单行内容包裹，多行代码使用多行内容包裹 转义符：\\ 需要转义的字符： \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 上面“文字链接”、“插入图片”、“插入图片，同时图片加链接”中需使用n个\\进行转义，结果刷新页面还有问题：一段文字涉及n个符号需要转义的 直接使用插入单行代码的形式（``）简单粗暴解决 表格： 表格有n列 表头为表格的第一行，其中某行最后一列没有数据展示，那当前这行的最后一列的“｜”也要写，不然页面展示出来的 表格的当前行会有问题，用法详见 JavaScript/JavaScript.md中数组方法的表格 表格列宽度会根据显示内容动态计算显示，会出现显示太窄||太宽了的情况，可使用 html div元素包裹表头内容，通过行内样式调整width的大小：用法详见 JavaScript/JavaScript.md中数组方法的表格 文字颜色：markdown本身不支持颜色，但是markdown兼容html，所以可以使用font标签包裹目标内容 color行内样式进行设置，用法详见 “目前项目中碰到的问题” 代码片段部分 上下与其他内容至少空出隔开，否则代码可能不能被正确识别 标题 ![图片][图片地址] ，标题和图片书写在一行 图片不会正常展示，图片需换行 目前项目中碰到的问题 gitbook install，报错`if (cb) cb.apply(this, arguments) TypeError: cb.apply is not a function`，node版本（v14.15.1）太高，使用 n 调整为 v10.22.0 就好了 gitbook serve 启动项目后，修改md文件未触发热更新 菜单栏有多级目录的情况下，一级目录最好不去对应具体的md文件，只是子级目录的一个总览 点击 展开收起效果 即可 html、css的代码未高亮 DevTools中iTerm2的部分 因为中间插入了代码片段，导致排序变乱 "},"doc/HTML/HTML.html":{"url":"doc/HTML/HTML.html","title":"HTML","keywords":"","body":"a标签 target属性常用值 _self：默认。在当前页面打开链接 _blank：在新窗口中打开链接 "},"doc/CSS/CSS.html":{"url":"doc/CSS/CSS.html","title":"CSS","keywords":"","body":"相邻兄弟选择器(Adjacent sibling selector) 适用场景：二者有相同的父元素，选择紧接在一个元素后的另一个元素 e.g. 给紧跟在 h1标签 后出现的 p标签 设置上外边距 h1 + p {margin-top:50px;} background复合属性写法 background: background-color background-image background-repeat background-attachment background-position/background-size; background-attachment scroll：背景图片随着页面的滚动而滚动（默认值） fixed：背景图片不会随着页面的滚动而滚动 background-position top center bottom left right，如果仅规定了一个关键词 第二个值将是“center” top left 和 left top 是一样的，都能够识别（已写demo验证） background-size cover：等比缩放背景图 以完全覆盖掉 背景区域 contain：在背景区域内完整地、最大化地展示 背景图（宽高等比缩放） percentage：将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为\"auto(自动)\" 背景区域非正方形的情况下： width > height: contain === 100% auto height > width: contain === auto 100% sass "},"doc/JavaScript/JavaScript.html":{"url":"doc/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"原型 和 原型链 作用域 和 闭包 作用域 词法作用域 js是词法作用域，即静态作用域，相对于词法作用域的是 动态作用域 自由变量 定义 一个变量在当前作用域（全局作用域、函数作用域 或者 块级作用域（ES6））没有定义，但被使用了； 查找规则 会向上级作用域一层一层依次寻找，直至找到为止；如果到全局作用域都没找到，则报错 xx is not defined 闭包 作用域应用的特殊情况 函数作为参数被传递 函数作为返回值被返回 自由变量查找规则 自由变量的查找是在函数定义的地方向上级作用域查找，而不是函数执行的地方 闭包的应用场景 ```javascript // 函数作为返回值 funciton create () { let a = 100; return function () { console.log(a); } } let fn = create(); let a = 200; fn(); // 100 // 函数作为参数 function print (fn) { let a = 200; fn(); } let a = 100; function fn () { console.log(a); } print(fn); // 100 ``` 单线程 和 异步 == 和 === 的区别和使用场景 == 会发生隐式类型转换 除判断 变量 == null外，其他都用 ===const obj = { name: 'xiaohei' }; if (obj.age == null) { // TODO } // 相当于 if (obj.age === null || obj.age === undefined) { // TODO } 字符串方法 this指向 long long age的认知 普通函数的调用，函数内部的this：指向window 构造函数的调用，函数内部的this：指向实例化以后的对象 箭头函数的调用，函数内部的this：继承自父级作用域 其实之前的认知，每句前半条件的部分较片面，重新认识：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this最终指向的是那个调用它的对象，参考 如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，箭头函数中this指向继承自上级作用域 setTimeout || setInterval 入参是个函数：非箭头函数内部this指向window，箭头函数内部this指向上级作用域 如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象 如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 js只有全局作用域和函数作用域，js对象的属性间不能用this相互调用 ```javascript // 例1: var o = { a:10, b:{a:12, fn:function(){ console.log(this.a); console.log(this); } } }; window.o.b.fn(); / 12 o.b / var tempFn = o.b.fn; tempFn(); / undefined window / // 例2: var dog = { nick: 'xiaohei', age: 11, baseInfo: ${this.nick} is ${this.age} years old, baseInfoFn: function() { console.log(${this.nick} is ${this.age} years old); }, baseInfoArrowFn: () => { console.log(${this.nick} is ${this.age} years old); }, } console.log(dog.baseInfo); // undefined is undefined years old dog.baseInfoFn(); // xiaohei is 11 years old dog.baseInfoArrowFn(); // undefined is undefined years old ``` 改变this指向，call、apply、bind都是Function.prototype上的方法，三者实现的功能相同，只是入参 和 使用方法上稍有不同，可以相互替换使用 call: fn.call(this, arg1, arg2..., argn) apply: fn.apply(this, [arg1, arg2..., argn]) bind: fn.bind(this, arg1, arg2..., argn)，call 和 bind的区别在于后者返回的是一个函数，需要调用后才能执行 常用的： 将类数组转化为数组：Array.prototype.slice.call(类数组) || Array.prototype.slice.apply(类数组) || Array.prototype.slice.bind(类数组)() 判断数据类型：Object.prototype.toString.call(某类型的数据) || Object.prototype.toString.apply(某类型的数据) || Object.prototype.toString.bind(某类型的数据)()// 手动实现bind（使用call || apply） Function.prototype.myBind = function () { // 将类数组转化为数组 const argumentsArr = Array.prototype.slice.call(arguments); // 实参中 第一个参数 为this指向 const targetPoint = argumentsArr.shift(); // 当前函数内部 this指向实例化以后的对象，缓存一下供return中使用 const self = this; return function () { return self.call(targetPoint, ...argumentsArr); // 或者 // return self.apply(targetPoint, argumentsArr); } } // 手动实现call（使用apply） Function.prototype.myCall = function () { const argumentsArr = Array.prototype.slice.call(arguments); const targetPoint = argumentsArr.shift(); this.apply(targetPoint, argumentsArr); } // 手动实现apply（使用call） Function.prototype.myApply = function () { const argumentsArr = Array.prototype.slice.call(arguments); const targetPoint = argumentsArr.shift(); // apply 第二个参数为 数组，上行代码已经shift掉了一个最前面的项，所以传入call 直接解构第0项就ok了 // 使用的时候就是 谁调用了 myApply，谁调用了 myCall，this就指向谁 this.call(targetPoint, ...argumentsArr[0]); } for key in 和 for value of for key in 数组 || 对象，遍历的是对象的 键名：数组中key 指的是 索引，对象中key 指的是 属性名 原型上的可枚举属性也会被遍历到（测试发现：非手动添加的 原型上 本身自带的方法 都是不可枚举的） 如果使用 for key in Object.keys(数组 || 对象)，Object.keys()方法只会返回对象本身具有的可枚举属性，不会包含原型上的可枚举属性 补充可枚举属性： js中基本包装类型的原型属性是不可枚举的，如Object, Array, Number等prototype非手动定义的属性； 对象自身 || 原型上通过 对象.属性 的方式添加属性，都是可以枚举的；使用 Object.defineProperty(object, propertyname, descriptor) 的方式定义属性，descriptor对象中enumerable属性值为Boolean类型 表示是否可以被枚举 for value of 可用于遍历Itrator类型实例，比如数组集合map等，遍历的是对象的 value值，不适用于遍历Object类型的变量 会报错 数组方法 方法名 作用 返回值 纯函数 备注 push 数组后增 数组length 是 unshift 数组前增 数组length 是 pop 数组后删 被删除的项 是 shift 数组前删 被删除的项 是 indexOf 寻找数组中某项对应的下标 Number(-1表示不包含目标项) 否 一般针对简单数据类型 findIndex 寻找数组中某项对应的下标 Number(-1表示不包含目标项) 否 一般针对引用类型，回调函数入参：(callback(Value[, Index[, Array]])[, thisArg])；thisArg 执行 callback 时用于 this 的值 find 寻找数组中第一个满足某条件的项 目标项 or undefined 否 同findIndex fitler 过滤数组中所有满足某条件的项 Array 否 同findIndex includes 判断数组中是否包含某项 Boolearn 否 some 判断数组中是否包含满足某条件的项 Boolearn 否 同findIndex every 判断数组中是否所有项都满足某条件 Boolearn 否 同findIndex map 根据需求格式化数组 Array 否 同findIndex forEach 单纯迭代 无 否 同findIndex concat 数组合并 Array 否 slice 数组截取 Array（由被截取项组成） 否 入参：([beginIndex[, endIndex]]) reduce 数组累加器 可以是任意类型 否 使用说明 splice 数组截取并插入新项 Array（由被删除项组成） 是 (startIndex[, deleteCount[, item1[, item2[, ...]]]])；deleteCount为0时，新项就从start位置开始插入；如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除 sort 排序 排序后的数组 是 入参：([compareFunction])，不传compareFunction函数，默认排序顺序 是将元素转换为字符串，然后比较它们的UTF-16代码单元值序列；针对元素全是数字的数组 对元素进行 升序 和 降序排列，compareFunction 写法固定：升序：arr.sort((a, b) => a - b)；降序：arr.sort(a, b) => b - a 几点说明 是否修改原数组，也可以说是 是否有副作用，是否是纯函数 入参为回调函数的几个方法，回调函数的入参相同 findIndex、find、fitler、some、every、map、forEach：回调函数入参：(callback(Value[, Index[, Array]])[, thisArg])；thisArg 执行 callback 时用于 this 的值 针对 slice方法 的几点说明 该方法也可用于 String类型，返回值为 被截取项组成的String 如果省略 beginIndex，则 slice 从索引 0 开始 --> 数组的浅拷贝 截取部分不包含 endIndex 省略endIndex会截取到末尾；负数表示从末尾开始截取：-1表示最后一项，-2表示倒数第二项 封装insert方法Array.prototype.insert = function(index, item) { this.splice(index, 0, item); } 对象方法 hasOwnProperty 判断属性（键名）是否为对象的 自定义属性，而非原型链上的属性 翻译成人话判断手动定义的属性是否没有被定义在原型链上 --> 返回值类型为Boolean 注： 如果原型链上的方法被非法占用，非手动挂载到原型链（prototype）上，类似于 var obj = { toString: () => {} }; 那么obj.hasOwnProperty(toString) 结果为true 非原型链上的属性 指的是包含原型链上的自定义属性，实际使用的过程中也是在排除这部分属性 ```javascript const obj = { name: 'xiaohei' }; Object.prototype.myFn = () => {}; for (let key in obj) { console.log(key, obj[key]); }; // \"name\", \"xiaohei\" // \"myFn\", () => {} for (let key in obj) { if (obj.hasOwnProperty(key)) { console.log(key, obj[key]); } }; // \"name\", \"xiaohei\" ``` JavaScript中字符串的match与replace方法 match方法 match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配 match()方法的返回值为：存放匹配结果的数组。 replace方法 replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串 replace方法的返回值为：一个新的字符串 注：以上2个方法的参数在使用正则表达式时主要添加全局g，这样才能对字符串进行全部匹配或者替换 JavaScript中字符串的match与replace方法 var str = \"1 plus 2 equal 3\"; //match方法返回值为数组 var arr = str.match(/[0-9]/g) console.log(arr); // [\"1\", \"2\", \"3\"] var new_str = str.replace(/[0-9]/g, 'newstr'); //replace方法返回值为新的字符串 console.log(new_str); // new_str plus new_str equal new_str "},"doc/JavaScript/DOM.html":{"url":"doc/JavaScript/DOM.html","title":"DOM","keywords":"","body":"event事件对象 event.target 和 event.currentTarget的区别 event.currentTarget 会返回当前触发事件元素，event.target会返回触发事件的源头元素 event.currentTarget 在控制台展开查看的时候已经不存在了。如果想拿到它，可以使用变量进行缓存，然后再进行操作 1 2 3 document.querySelector('.ok').addEventListener('click', function (event) { console.log('event', event); // 展开后发现 event.currentTarget 值为null console.log('event.currentTarget', event.currentTarget); // 值正常 }); addEventListener方法的第三个参数 给HTML元素绑定事件有下面三种方法，以最常见的“click”事件为例 直接在对应的HTML元素标签上绑定函数，违反了HTML与JavaScript分离的准则，不推荐 Click Me! 在JS代码中指定元素的“onclick”方法，只能给一个事件绑定一个响应函数，重复绑定会覆盖之前的绑定 var btn = document.getElementById(\"submit\"); btn.onclick = onClickFn; 使用事件监听“addEventListener”绑定方法，可以绑定多个不同的函数，不会覆盖，推荐 var btn = document.getElementById(\"submit\"); btn.addEventListener(\"click\", onClickFn, false); 第三种方法“addEventListener”中的第三个参数是用来控制什么的呢 事件捕获 和 事件冒泡 还是以最常见的“click”事件为例，页面中标签由里到外层层嵌套 结构如同洋葱，当鼠标点击所看到的的按钮时，其实发生了一系列的事件传递：button实际上是被body“包裹”起来的，body是被html“包裹”起来的，html又是被document“包裹”起来的，document是被window“包裹”起来的。所以，在点击鼠标的时候，最先获得这个点击的是最外面的window，然后经过一系列传递 才会传到最后的目标button，当传到button的时候，这个事件又会像水底的泡泡一样慢慢往外层穿出，直到window结束。 综上，一个事件的传递过程包含三个阶段，分别为： 捕获阶段 目标阶段 冒泡阶段 说明： 事件的传递过程为：捕获阶段 --> 目标阶段 --> 冒泡阶段，对应的event.eventPhase分别为 1 --> 2 --> 3，很好记 目标阶段指的就是 包裹得最深的那个元素 “addEventListener”第三个参数是用来控制事件处理程序 事件捕获时触发 or 事件冒泡时触发 addEventListener的第三个参数设置为true和false的区别 true表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件； false表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件 第三个参数默认为false` Click Me! var div = document.getElementById('d'); var p = document.getElementById('p'); var span = document.getElementById('s'); function onClickFn (event) { var tagName = event.currentTarget.tagName; var phase = event.eventPhase; // event.eventPhase 事件传播的当前阶段，1 捕获阶段，2 目标阶段， 3 冒泡阶段 console.log(tagName, phase); } 1. 分别给三个元素添加事件监听，第三个参数设置为false，点击“Click Me!”： ```javascript div.addEventListener('click', onClickFn, false); p.addEventListener('click', onClickFn, false); span.addEventListener('click', onClickFn, false); // SPAN 2 // P 3 // DIV 3 ``` 1. p和div都是在冒泡阶段响应了事件，由于冒泡的特性，裹在最里层的span率先做出响应 2. addEventListener第三个参数设置为true，点击“Click Me!”： ```javascript div.addEventListener('click', onClickFn, false); p.addEventListener('click', onClickFn, false); span.addEventListener('click', onClickFn, false); // DIV 1 // P 1 // SPAN 2 ``` 在冒泡阶段，如果不希望事件继续往上传播，例如，冒泡到p的时候就停止传播，那么，可以在p的事件回调函数里面添加“event.stopPropagation” "},"doc/CodeSegment/CodeSegment.html":{"url":"doc/CodeSegment/CodeSegment.html","title":"CodeSegment","keywords":"","body":"css 删除a标签默认样式 a { text-decoration: none; color: #333; // 值为设计稿 目标样式 } 文字单行超出省略号儿 overflow: hidden; //超出的文本隐藏 text-overflow: ellipsis; //溢出用省略号显示 white-space: nowrap; //溢出不换行 文字n行超出省略号儿 overflow: hidden; text-overflow: ellipsis; display: -webkit-box; // 作为弹性伸缩盒子模型显示。 -webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列 -webkit-line-clamp: n; // n为显示的行数 隐藏滚动条，但是可以滚动 /* 水平方向 */ 滚动容器 { overflow-x: auto; scrollbar-width: none; /* firefox */ -ms-overflow-style: none; /* IE 10+ */ &::-webkit-scrollbar { display: none; } } /* 垂直方向 */ 滚动容器 { overflow-y: auto; scrollbar-width: none; /* firefox */ -ms-overflow-style: none; /* IE 10+ */ &::-webkit-scrollbar { display: none; } } js 阻止默认事件 Event.preventDefault();阻止事件冒泡 Event.stopPropagation(); 另 Event.cancelBubble = true; // MDN解释 Event.cancelBubble 属性是 Event.stopPropagation()的一个曾用名，查询网络得知其存在的意义在于 为兼容IE，都快2022年了 还有几个用IE的，阻止事件冒泡尽管用 Event.stopPropagation() 就完了阻止事件冒泡、同时阻止监听同一事件的其他事件监听器被调用 Event.stopImmediatePropagation(); 如果多个事件监听器被附加到相同元素的相同事件类型上，当此事件触发时，它们会按其被添加的顺序被调用。如果在其中一个事件监听器中执行 stopImmediatePropagation() ，那么剩下的事件监听器都不会被调用 paragraph const p = document.querySelector('p') p.addEventListener(\"click\", (event) => { alert(\"我是p元素上被绑定的第一个监听函数\"); }, false); p.addEventListener(\"click\", (event) => { alert(\"我是p元素上被绑定的第二个监听函数\"); event.stopImmediatePropagation(); // 执行stopImmediatePropagation方法，阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行 }, false); p.addEventListener(\"click\",(event) => { alert(\"我是p元素上被绑定的第三个监听函数\"); // 该监听函数排在上个函数后面，该函数不会被执行 }, false); document.querySelector(\"div\").addEventListener(\"click\", (event) => { alert(\"我是div元素,我是p元素的上层元素\"); // p元素的click事件没有向上冒泡，该函数不会被执行 }, false); 禁止蒙层底部页面跟随滚动的方法（pc、h5全平台兼容） function preventBodyScroll (isFixed) { const winScrollY = window.scrollY; const bodyEle = document.body; if (isFixed) { bodyEle.style.position = 'fixed' bodyEle.style.top = `-${winScrollY}px`; } else { bodyEle.style.position = ''; bodyEle.style.top = ''; window.scrollTo(0, winScrollY); // 回到原先的top } } 获取数组中某项的索引，indexOf Polyfill !Array.prototype.indexOf && Array.prototype.indexOf = function(item) { for(var i = 0; i 获取url query参数值 function getSearchParams() { const { search } = window.location; if (!search) return ''; return search .slice(1) .split('&') .map(group => group.split('=')) .reduce((searchParamsObj, item) => { searchParamsObj[item[0]] = item[1]; return searchParamsObj; }, {}); } 判断数据类型 function type (data) { var toString = Object.prototype.toString; var dataType = data instanceOf 'Element' ? 'element' : toString .call(data) .replace(/\\[object\\s(.+)\\]/, \"$1\") .toLowerCase(); return dataType; } 扩展运算符 合并对象 合并对象1 const obj1 = { name: 'xiaohei', age: 12, eat: 'fruit', } const obj2 = { ...obj1, color: 'black', } const {eat, ...targetObj} = obj2; // 注意前面的const console.log(targetObj); /* { name: 'xiaohei', age: 12, color: 'black', } */ 合并对象1 // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(''); } // good function concatenateAll(...args) { return args.join(''); } 将类数组转换为数组 function fn(){return arguments}; const arrayLike = fn('a', 'b', 'c', 'd'); console.log(Object.prototype.toString.call(arrayLike)); // [object Arguments] const arr1 = Array.prototype.slice.call(arrayLike); console.log(Object.prototype.toString.call(arr1)); // [object Array] const arr2 = [...arrayLike]; console.log(Object.prototype.toString.call(arr2)); // [object Array] 解构 Destructuring 对象解构 // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`; } // good function getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`; } // best function getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`; } 数组解构 const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; 获取图片宽高（较优解） const img = new Image(); img.src = \"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2020-04-07%2F5e8c1c1f397b9.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641609272&t=8166b79fc50ddaf648982d4171ad040f\"; // 图片来源于 百度图片 const check = function() { if (img.width || img.height) { // TODO clearInterval(interval); } } const interval = setInterval(check, 10); 日期转化为 时间戳 var now = new Date(); console.log('Date.getTime()', now.getTime()); // Date.getTime() 1639989558558 console.log('Date.valueOf()', now.valueOf()); // Date.valueOf() 1639989558558 console.log('+ Date', + now); // + Date 1639989558558 console.log('Date.parse()', Date.parse(now)); // Date.parse() 1639989558000 console.log('new Date(1639989558558)', new Date(1639989558558)); // new Date(1639989558558) Mon Dec 20 2021 16:39:18 GMT+0800 (中国标准时间) console.log('new Date(1639989558000)', new Date(1639989558000)); // new Date(1639989558000) Mon Dec 20 2021 16:39:18 GMT+0800 (中国标准时间) // 补充：获取 当前时间戳 的快捷方式：Date.now(); 这里是 Date对象的 now方法，不是上面的 now 变量哈 注： 以上运行结果来源于 Chrome 版本 96.0.4664.110（正式版本） (x86_64)，Date.parse()方法陈独秀 比其他几种方法得出来的结果早了 558ms 规避问题方案：在代码中多个转化后的时间戳进行比较操作时 注意使用一致的方法 判断当前时间是否是当天 function isCurrentDay(targetTimeStamp){ const startTimeStamp = new Date().setHours(0, 0, 0, 0); // dateObj.setHours(hoursValue[, minutesValue[, secondsValue[, msValue]]]); 返回 日期对象实例所表示时间的毫秒数 const endTimeStamp = new Date().setHours(23, 59, 59, 999); return startTimeStamp js复杂数据类型的深拷贝 // TODO 当前code弊端：不能拷贝 对象本身具备的 不可枚举属性（通过 defineProperty定义的enumerable属性值为false的属性） const deepClone = (obj = {}) { if (typeof obj !== 'object' || obj === null) { return obj; } let result; if (result instanceOf Array) { result = []; } else { result = {}; } for (let key in obj) { // 判断是否为手动定义在 非原型链（prototype）上 的属性 if (obj.hasOwnProperty(key)) { result[key] = deepClone(obj[key]); } } // 也可以写成： // Object.keys()只返回对象本身具有的可枚举属性 /* for (let key in Object.keys(obj)) { result[key] = deepClone(obj[key]); } */ // hasOwnProperty、Object.keys 代码的意义在于不会去拷贝对象的继承属性 return result; } 动态插入js // 动态异步引入js function createScript(src) { var scriptEle = document.createElement(\"script\"); scriptEle.src = src; scriptEle.async = false; // 此行代码作用：1、js是被异步加载的；2、同时引入多个js（函数被调用多次）执行脚本的顺序 将与 代码中的书写顺序 保持一致，不受加载快慢影响 document.querySelector(\"body\").appendChild(scriptEle); } createScript(targetScriptSrc); // 动态同步引入js function loadAsyncScript(src, callback = function() {}) { var scriptEle = document.createElement(\"script\"); scriptEle.src = src; scriptEle.async = false; // 此行代码作用：1、js是被异步加载的；2、同时引入多个js（函数被调用多次）执行脚本的顺序 将与 代码中的书写顺序 保持一致，不受加载快慢影响 document.querySelector(\"body\").appendChild(scriptEle); scriptEle.onload = function() { // script标签的onload事件 是在外部js文件被加载完成并执行完成后才被触发的 callback(); } } loadAsyncScript(targetScriptSrc, callback); 背景：JS 可能会操作DOM（修改 DOM结构 || 样式），因此 JS 的执行过程 不能和 HTML||CSS 的下载||执行过程 并行，自上到下解析HTML的过程中 若碰到需顺序加载的外联 JS，会暂时中止 HTML 的解析流程，等候脚本下载和解析执行完成后再继续 进行之前中断掉的 HTML 解析流程，这就导致了 script 标签外联 JS 加载存在一些缺陷：会影响整个页面效率，一旦网速不好整个网站将等待 JS 加载 而不进行后续渲染，由于中断了 HTML 解析流程，导致页面空白，影响体验，以前的写法是将 script 标签写在 body 最后面，等 DOM 全部解析完成后才加载 JS，HTML5 标准有另一套异步加载 JS 的方法：defer 和 async 属性 script标签加上defer、async两个之中的任意属性之后,在js真正执行之前都不会阻止html的加载 defer defer=“defer” 或直接写 defer 就可以让这个 script 外联的 JS 变成异步加载 HTML 解析流程中若碰到外联 JS，会开辟新线程来下载脚本，下载完成后不会立即解析，不会阻塞 HTML 的解析流，等到 HTML 解析完毕后（不包括下载完里面的资源），再进行脚本的执行解析 该方法只有 IE 和一些高版本的 firefox 和 chrome 可以用，当前看（20211223）比较少被使用 这种方式可以在 script 标签里面写代码 注意：IE6 和 IE7 的异步加载最多只能有 2 个，超过两个时必须等前两个加载完才会加载第三个 理论上，添加 defer 属性后 可以保证顺序执行。但实际 却发现顺序也不能确定。在JavaScript高级程序设计(第3版)中有这么一句： 在现实当中，延迟脚本不一定按顺序执行，也不一定会在DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本 async async 是 asynchronous（异步） 的缩写，是 HTML5 标准 HTML 解析流程中若碰到外联 JS，会开辟新线程来下载脚本，下载完成后立即解析执行，且解析流程会中断 HTML 解析流程，等到脚本执行完成后才会继续进行之前中断掉的 HTML 解析流程 该属性除了 IE6 ～ IE8 其他的浏览器都好用，相对defer使用更广泛些 该方式不能把代码写在 script 标签里，只能引用外部脚本（虽然标准是这么写的，但现在随着内核升级 async 的 script 标签里也可以写代码（即在没有 src 情况下）） 设置了 async=true 的 JS 代码不能保证是顺序执行的，按照 race 的方式哪个脚本先下载完就先解析哪个脚本 可以通过设置 async=false以保证代码执行顺序 与 代码书写顺序 保持一致（即使下面的脚本相比上面的脚本 被先加载到本地） 注： 设置async=false，脚本仍然会异步加载 async=false 与 不写async完全是两种情况： 静态引入的script如果不设置 async 那脚本压根就不会异步加载 动态引入的script async默认值为true defer 和 async 这两个属性不能一起使用 结： defer || async属性都能实现 js脚本 的异步加载，defer是 等HTML解析完毕后 才进行js解析；async在脚本异步加载完成后 就进行js解析 js是单线程的，解析js会中断 HTML解析 补充：script标签onload事件：script标签的onload事件 是在外部js文件被加载完成并执行完成后才被触发的 截流throttle 定义：事件被触发后 一段时间内 回调函数只能被执行一次，期间事件再次被触发函数不执行 实际开发场景：拖拽元素（需设置元素标签 draggable = \"true\"）间隔n秒获取一次位置信息，对应drag事件function throttle (fn, delay = 1000) { let timer = null; return function () { if (timer) { return; } setTimeout(() => { fn.apply(this, Array.prototype.slice(arguments)); timer = null; }, delay); } } domEle.addEventListener(eventType, throttle (function (e) { /* offsetX、offsetY是事件对象上的属性 offsetLeft、offsetTop是dom对象上的属性，不受drag事件的影响，页面渲染完毕后就不会改变了 */ console.log(e.offsetX, e.offsetY); }, 2000)); 防抖debounce 定义：事件被触发，n秒后执行回调函数被，如果期间事件再次被触发，则重新计算时间 实际开发场景： input元素的 keyup事件 body元素的 scroll事件 window元素的 resize事件function debounce (fn, delay = 1000) { let timer = null; return function () { if (timer) { clearTimeout(timer); } setTimeout(() => { /* 注： 1.事件注册中 事件回调函数throttle || debounce中this指向事件源，在这里需使用call || apply || bind进行指明 1. 已验证 下面的代码中this指向的是时间源 2.ES5以后，apply第二个参数支持直接传入 类数组，所以可以写成 fn.apply(this, arguments); */ fn.apply(this, Array.prototype.slice(arguments)); timer = null; }, delay); } } domEle.addEventListener(eventType, debounce (function (e) { console.log(this.value); }, 2000)); 手写深度比较两个变量是否值相等 function isObject (obj) { return typeof obj === \"object\" && obj !== null; } function isEqual (obj1, obj2) { // 简单数据类型直接进行全等比较 if (!isObject(obj1) || !isObject(obj2)) { return obj1 === obj2; } // 引用类型指针指向的地址相同 || 值类型全等 if (obj1 === obj2) { retrun true; } // 根节点对象自身 属性数量如果不相等，直接返回false if (Object.keys(obj1).length !== Object.keys(obj2).length) { return false; } // 枚举每个属性值 逐个进行比较 for (let key in obj1) { const res = isEqual(obj1[key], obj2[key]); if (!res) return false; } return true; } "},"doc/Chrome/Chrome.html":{"url":"doc/Chrome/Chrome.html","title":"Chrome","keywords":"","body":"Chrome65+ local overrides 介绍：通过overrides可以在浏览器中直接修改一些请求的返回数据，类似于使用fiddler代理抓包重写返回数据一样 用途：调试线上（pre || prd）页面接口返回的静态资源（html、css、js、图片） 使用方法： 打开开发者工具的sources页，找到overrides tab 点击“Select folder for overrides”按钮选择本地文件夹 勾选“Enable local overrides” 注：勾选状态下 如果选择的本地文件夹不为空，network tab处会出现一个黄色的三角形提示；如果文件夹中的 文件夹路径、文件名 与 network中x请求全等，则x请求的返回结果就会被立即重写 刷新页面 切到network tab，找到需要修改的目标资源右键选择“save for overrides”，点击之后就会自动跳转到sources tab的overrides，在overrides中编辑资源即可，图片文件的替换可以直接在本地文件夹中操作 Chrome进入全屏模式后 隐藏工具栏（包含标签页tab、地址栏、书签） 方法1:“视图”菜单 -> 取消“在全屏模式下始终显示工具栏”勾选 方法2:“Shift + command + f”快捷键，重复这个操作可以 显示工具栏 开发者工具的移动设备仿真器打开||关闭 手机||平板电脑外观图形 三点菜单允许你显示或隐藏其他设置，切换\"Show||Hide device frame\"(设备边框,如果可用，手机或平板电脑的外观图形） Chrome（版本 96.0.4664.110（正式版本） (x86_64)） 开发者工具 -> Network 接口请求中的 Payload 放到了单独的tab，之前是在 Headers tab中 macOS Chrome无法访问自签名https页面，以往版本可以选择跳过，继续访问，但是新版本Chrome不允许继续，并显示ERR_CERT_INVALID 在Chrome该页面上，直接键盘敲入这11个字符：thisisunsafe；注意不是地址栏，而是页面内直接盲打 "},"doc/Chrome/skills.html":{"url":"doc/Chrome/skills.html","title":"使用技巧","keywords":"","body":"Chrome 浏览器 Dev 94 开发者工具现已支持中文 Chrome 浏览器 Dev 94.0.4603.0 开发人员工具现已支持中文 具体设置方法 打开Chrome开发者工具 点击右上角“⚙️”图标进入到设置页面 左侧侧边栏选中“Preferences” 右侧main区域 “Appearance”大项 下的 “Language”小项，选择“Chinese - 中文”即可 常用插件 Header Editor 说明：管理浏览器请求，包括修改请求头和响应头、重定向请求、取消请求 使用场景：本地开发启动前端项目，页面有登录校验，登录成功后 前端发起ajax接口调用才能调通的场景 一般情况下在同浏览器窗口 新建标签页打开测试环境对应页面，只要本地启动的前端项目的域名（SwitchHosts中配置的host）包含测试环境对应页面域名即可共享同domian下的cookie 如果还不能调通，使用Header Editor添加一条规则，将测试环境成功登录后的cookie请求头信息配置到 本地前端项目域名下 "},"doc/DevTools/DevTools.html":{"url":"doc/DevTools/DevTools.html","title":"DevTools","keywords":"","body":"本地启动服务打开页面 http-server npm install http-server -g 在目标目录打开命令行 执行 \"http-server -p 自定义端口号\" npm源管理器 && node版本管理 npm源管理器：nrm 安装:sudo npm install -g nrm 查看是否安装成功:nrm --version ❯ nrm --version 1.2.3 列出可选择的源:nrm ls 前面带 * 号的表示正在使用的源 ❯ nrm ls npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ *tencent ------ https://mirrors.cloud.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/ taobao ------- https://registry.nlark.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ 切换使用的源:nrm use npm ❯ nrm use cnpm Registry has been set to: https://r.cnpmjs.org/ 删除一个源:nrm del \\ ❯ nrm del xdf delete registry xdf success 添加一个源:nrm add \\ \\ ❯ nrm add xdf http://npm.koolearn.com/ add registry xdf success 测试源速度:nrm test 测试一个源的响应时间：nrm test \\ ❯ nrm test npm npm ------ 1612ms 测试所有源的速度：nrm test ❯ nrm test npm ------ 1317ms yarn ----- 866ms tencent -- 316ms * cnpm ----- 572ms taobao --- 404ms npmMirror - 3440ms xdf ------ 957ms 访问源的主页：nrm home \\ node版本管理工具n 安装：sudo npm install -g n 查看是否安装成功:n --version ❯ n --version v7.4.1 安装或使用一个node版本：sudo n node-version, 如果本地已存在这个node-version，则切换到这个node-version; 如果本地不存在这个node-version，则下载安装并切换 ❯ sudo n 8.12.0 installing : node-v8.12.0 mkdir : /usr/local/n/versions/node/8.12.0 fetch : https://nodejs.org/dist/v8.12.0/node-v8.12.0-darwin-x64.tar.xz installed : v8.12.0 (with npm 6.4.1 查看所有已经安装的node版本：n 使用或安装稳定的官方发布：sudo n stable ❯ sudo n stable installing : node-v14.18.1 mkdir : /usr/local/n/versions/node/14.18.1 fetch : https://nodejs.org/dist/v14.18.1/node-v14.18.1-darwin-x64.tar.xz installed : v14.18.1 (with npm 6.14.15) 删除一个node版本：n rm node-version iTerm2配置 iTerm2 + oh-my-zsh + powerlevel10k 安装oh-my-zsh curl: export REMOTE=https://gitee.com/imirror/ohmyzsh.git sh -c \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)\" vim ~/.zshrc，设置 ZSH_THEME=\"agnoster\" vim简单使用 修改： i 保存并关闭： esc --> :wq 切换agnoster主题后会出现乱码，需要安装额外的字体 Meslo for Powerline，安装好后在 Preferences->Profiles->Text->Font中进行配置 和\"agnoster\"平级的，也可以安装powerlevel10k/powerlevel10k主题 手动克隆主题相关git仓库 git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ~/powerlevel10k echo 'source ~/powerlevel10k/powerlevel10k.zsh-theme' >>~/.zshrc Set ZSH_THEME=\"powerlevel10k/powerlevel10k\" in ~/.zshrc 注意 2 3 4步操作后 需重启iTerm.app 方能看到效果 将iTerm2配置成 Visual Studio Code 的默认终端 打开iTerm2窗口，点击左上角菜单 iTerm2 --> Make iTerm2 Default Term 即可 注意：在vscode中使用配置了主题的 iTerm2，字体显示可能会不正常，解决方案： 打开iTerm2按住“command + ,”打开Preferences，在 Profiles --> Text --> Font 中查看当前使用的字体 打开vscode按住“shift + command + p”打开“命令面板”，检索“setting.json”，选择“Preferences： Open Setting（JSON）”，在JSON文件中追加字体配置，将下面json代码中的“Meslo LG S for Powerline”替换成你iTerm2使用的字体 即可 \"editor.fontFamily\": \"Meslo LG S for Powerline\", \"terminal.integrated.fontFamily\": \"Meslo LG S for Powerline\" 窗口基本使用（与Chrome基本相同） 打开新窗口：command+n 打开新标签页（tab）：command+t 关闭当前标签页：command+w 多个标签页切换：control+Tab 在终端（iTerm2 || Mac自带Terminal 都适用）中通过 命令的方式打开 文件夹 在 Finder 中显示 在终端中cd到 目标文件夹名 的根目录 使用“open 目标文件夹名“命令 使用 Visual Studio Code 打开 在 Visual Studio Code 中安装“code”命令 打开VSCode command+shift+p –> 输入shell command –> 点击提示Shell Command: Install ‘code’ command in PATH 输入shell command时可以同步看到“Shell Command: Uninstall ‘code’ command in PATH”，点击可卸载“code”命令 在终端中cd到 目标文件夹名 的根目录 使用“code 目标文件夹名“命令 git相关 本地配置 查看git配置信息：git config --list 查看git用户名：git config user.name 查看邮箱配置：git config user.email 全局配置用户名：git config --global user.name \"nameVal\" 全局配置邮箱：git config --global user.email \"email@qq.com\"常用命令 git branch -a git checkout -b localBrancheName remoteBranchName git remote update origin 存疑：网上看git fetch也可以解决这个问题，git fetch干什么用的 git branch -d localBrancheName || git branch --delete localBrancheName git push origin -d remoteBranchName || git push origin --delete remoteBranchName git reset --mixed HEAD^ git reset --soft HEAD^ git reset --hard HEAD^ git commit amend // 然后通过vim修改即可：键入“i”进入INSERT修改模式，修改完成后点击“esc”再键入“:wq会车”即可 git subtree push --prefix _book origin release git remote // 查看远程仓库 git remote -v // 查看权限 git remote add 远程仓库名(e.g. github) git仓库地址(https://github.com/xxx.git || git@github.com:xxx.git) git push 远程仓库名(e.g. github) 分支名(e.g. master) // 将 origin仓库master分支的代码 推送到 github仓库的master分支 git push 远程仓库名(e.g. github) release:master // 将 origin仓库release分支的代码 推送到 github仓库的master分支 公司gitlab 第二个push： 应用场景：不希望在github上暴露gitbook源码，将gitbook build后的文件push到 github新建的仓库 实际origin --> github中另外一个仓库 --> .gitignore 简介：每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些 文件||文件夹 是不需要被添加到版本管理中的。比如这个基于gitbook框架的项目：根目录下的node_modules 和 _book 文件夹，这些不需要提那家到版本管理中的 文件||文件夹 在项目中很重要，但是它们占用内存也是很大的，所以一般我们使用Git管理的时候 会将其添加到.gitignore文件中 常用规则 /mtk/ 过滤根目录下的mtk文件夹 包含里面的所有文件 *.zip 过滤所有.zip文件 /mtk/do.c 过滤根目录下的mtk文件夹中的do.c文件 通过以上规则的配置：被过滤掉的文件就不会出现在你的Git仓库中了，当然本地库中还有，只是push的时候不会上传 除了以上规则，它还可以指定要将哪些文件添加到版本管理中（include 和 exclude 的区别） !src/ 不过滤该文件夹 !*.zip 不过滤所有.zip文件 !/mtk/do.c 不过滤该文件 配置语法： 以斜杠/开头表示目录； 以星号*通配多个字符； 以问号?通配单个字符 以方括号[]包含单个字符的匹配列表； 以叹号!表示不忽略(跟踪)匹配到的文件或目录； 此外，git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； 示例说明 规则：fd1/* 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； 规则：/fd1/* 说明：忽略根目录下的 /fd1/ 目录的全部内容； 规则： /* !.gitignore !/fw/bin/ !/fw/sf/ 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录 创建.gitignore文件 常规的windows操作（windows下不允许在资源管理器中直接新建 匿名文件，所以先新建“gitignore.txt”文件） 项目根目录下创建gitignore.txt； 编辑gitignore.txt，写下你的规则，例如加上node_modules/； 打开命令行窗口，切换到 项目根目录； 执行命令ren gitignore.txt .gitignore ren 即 “rename” 用Git Bash 根目录下右键选择“Git Bash Here”进入bash命令窗口； 输入vim .gitignore 或 touch .gitignore命令，打开文件（没有文件会自动创建）； 按i键切换到编辑状态，输入规则，例如node_modules/，然后按Esc键退出编辑，输入:wq保存退出git通过ssh连接github 本地生成ssh密钥（包含 私钥id_rsa 和 公钥id_rsa.pub） 终端中输入‘ssh-keygen -t rsa -C \"你的邮箱账号\"’ 注意：如果已经生成过 id_rsa 和 id_rsa.pub 的，可通过\"rm id_rsa\"和\"rm id_rsa.pub\"将密钥删除，生成的sshkey能用于多个代码托管平台 登入github，进入setting --> SSH and GPG keys --> New SSH key Title内容 随意，Key内容 对应公钥id_rsa.pub文件中的内容，然后点击“Add SSH key”保存 终端中输入 “ssh -T git@github.com”命令进行测试 前端静态资源项目部署到github 通过 “username.github.io/项目名/” 访问 进入 Github 项目的 Settings 拉到最下面的 Github Pages，点击“Check it out here!” 选择目标分支 和 目标根目录即可 通过 “username.github.io” 访问（访问链接不希望有 /项目名 这个后缀） 创建名为 username.github.io 的项目 重复 上面123 emmet语法 简介：Emmet是一套面向文本编辑器的插件，它允许通过内容辅助高速度的编写和编辑HTML、CSS和其他结构化的代码格式，只要能安装他的编辑器都能使用，大部分编辑器都可以使用该语法规则,我们平时开发的Sublime Text、Eclipse、Notepad++、VS code、Atom、Dreamweaver等等编辑器都可以使用。 基本用法，更多语法详见Cheat Sheet 子节点 > li --> 兄弟节点 + 上级节点 ^ li>span^^div ^上一级，^^上两级 --> 倍增 * td*5 --> ID属性 # class属性 . 自定义属性 文本 {} 这是一篇markdown 组 () li>span)+div --> 数字序列 $ li.item$*10 --> Header 1 Header 2 Header 3 li.item$$*5 --> li.item$@-*3 倒序：@- --> li.item$@3*3 从n开始：@n --> HTML模版 ! --> tab Document 微信宿主环境 h5页面调试 调研背景：H5页面在 微信环境中打开 与 在其他宿主环境（手机浏览器、PC端手机模拟器）中打开 展示样式不一致 微信X5内核：该内核是腾讯的浏览服务，是用来帮助应用开发商大幅改善应用体验，有效提升开发，运营，商业化效率的，但是，被用户反馈视频兼容性不好，打开速度慢，没有夜间模式等等问题。通过关闭微信X5内核，使用系统内部原生WebView，可以提升整体速度和使用体验 方法一：Chrome inspect调试 Android 微信X5内核 H5页面 微信X5内核 && 手机USB调试模式 && PC chrome://inspect 调试微信端打开的H5页面 微信X5内核（如遇链接打不开 转化成二维码使用微信扫一扫再试） 如何查看你的微信X5内核是否被启用 打开一篇公众号文章或者一个微信内部网页，在页面内的顶部往下拉，如果看到“QQ浏览器X5内核提供技术支持”这一行字样，说明你正在使用微信X5内核 启用 微信X5内核（链接均为 在微信环境打开） http://debugmm.qq.com/?forcex5=ture 注：启用微信X5内核 只针对Android端 微信App，IOS端 微信App 访问此链接为空白页 关闭 微信X5内核 http://debugmm.qq.com/?forcex5=false 已启用 微信X5内核的情况下，打开 tbs调试页面 http://debugtbs.qq.com 点击“DebugX5”进入“X5 调试页面”，进入信息tab 打开下图中三项调试功能 如果暂未启用 || 已关闭 微信X5内核，访问 http://debugtbs.qq.com 后会跳转至 错误信息页面 注：打开tbs调试页面 只针对Android端 微信App，IOS端 微信App 访问此链接为 错误提示页 开启手机USB调试模式（20211217 以Android终端红米K40为例） 设置 --> 我的设备 --> 全部参数 --> 连击“MIUI版本” 会有toast提示框 提示“开发者模式”是否打开，“开发者模式”被打开后 设置 --> 更多设置 --> 开发者模式 --> 往下滑找到调试tab，打开“USB 调试” && “USB调试（安全设置）” PC（20211217 以MacBook Pro macOS Big Sur为例） chrome://inspect 调试微信访问的 H5页面 PC端 使用chrome访问“chrome://inspect” 线缆链接手机 和 PC 坑点：使用手机充电线缆进行连接（usb端连接至mac扩展坞），连接状态及不稳定 解决方案：使用mac充电线（ 双端type c的线）链接即可（红米K40充电口为 type c接口） 在手机微信中打开 目标h5链接，在inspect页面 Devices选项中，就会出现微信WebView页面了，然后点击 需要调试页面 下面的inspect按钮，及可进行调试 扩展：调试 在 Android Chrome App中 打开的h5页面： Android Chrome App && 手机USB调试模式 && PC chrome://inspect Chrome App无需特别设置，手机USB调试模式、PC chrome://inspect 与 上面相同 注： 如果点击“inspect”后出现的页面是个空白页，上面显示“HTTP/1.1 404 Not Found”，PC Chrome进正向代理翻墙即可 IOS端H5页面调试 暂时没用到，后续碰到了再研究 方法二：使用 微信开发者工具 微信开发者工具下载 安装打开后选择 “公众号网页项目”，键入 目标h5页面url 即可进行调试 流程图绘制工具 在线的diagrams，app传送门 Chrome插件 FeHelper：集成了 “JSON美化工具”、“二维码/解码”、“图片转Base64”等功能 Header Editor：目前我在开发中的应用场景是：自定义页面接口请求头（页面中接口需要登录才能正常访问，前端本地启动项目后 同时在新标签页访问 pre || prd 对应页面并登录 但同n级域名的开发页面仍获取不到登录肽，使用插件在请求头中手动配置cookie） Mac虚拟机运行window 安装虚拟机：VMware Fusion Player 12（20200820 VMware Fusion 12 正式发布：个人用户可免费使用用VMware Fusion Player（VMware Fusion阉割版），下文称vmware），安装步骤： 注册VMware Fusion Player 账号并激活 下载软件 获取软件安装需要的license 安装激活 window7企业版下载：I Tell You 创建虚拟机 打开vmware创建新的虚拟机（拖入下载好的ISO文件） 集成级别选择了“更加独立”（貌似这样会更加安全） 安装前（点 长得像播放器一样的按钮 后开始安装）的注意事项： mac系统偏好设置 --> 安全性与隐私 --> 允许vmware...... 尽量在设置中将“软盘“移除 window7企业版激活 以管理员身份启动cmd 输入slmgr /skms kms.03k.org 输入slmgr /ipk 33PXH-7Y6KF-2VJC9-XBBR8-HVTHH 输入slmgr /ato vmware虚拟机的使用 启动、挂起、关机 拖文件、复制粘贴文件 互传文件操作需安装VMware Tools，安装方法： VMware Fusion菜单栏：虚拟机 --> 安装 VMware Tools，如果“安装 VMware Tools”为不可点击的灰色按钮，转至 2 在应用程序中找到VMware图标，右击“显示包内容”，打开 x/VMware Fusion.app/Contents/Library/isoimages路径，在isoimages文件夹中找到 虚拟机中系统 对应的iso文件（本例中为window7，即window.iso）将其复制到mac桌面 在虚拟机界面 选择光盘或光盘映像，然后找到刚才的iso文件，然后点击 连接 CD/DVD 双击 DVD驱动器进行VMware Tools安装 可能出现的问题：提示无法安装，需更新window系统至SP1 解决方案：重新下载 window7企业版 安装完成后 “断开连接 CD/DVD”，删除mac桌面的iso文件即可 注： iso文件之所以要复制出来是因为 虚拟机选择光盘或光盘映像 的时候无法打开 Fusion.app/Contents/Library/isoimages路径（是灰色的），放到桌面只是为了好找 如果步骤5中 只是操作了删除mac桌面的iso文件，但是未“断开连接 CD/DVD”，那么启动虚拟机的时候会有报错提示：已经挂载了磁盘但是找不到文件路径 碰到的问题及解决方案 连接U盘后，“我的电脑”中未显示 目标盘符： 背景：启动虚拟机 插入U盘后： 虚拟机-->设置-->USB和蓝牙 选项中 已连接的USB设备列表 已显示 目标U盘； 虚拟机-->USB和蓝牙 子菜单中有 断开目标U盘 选项； “我的电脑”-->属性-->设备管理器-->存储控制器 中能够目标U盘，右键“更新驱动程序”没有效果： 解决过程 排查方向一（错误）：因为 目标U盘之前 在其他Windows系统物理机上可以被正常使用，所以认为问题的原因是 mac环境下 VMware Fusion Player 12 Windows虚拟机不识别U盘，全网检索相关解决办法，但无非是要达成1.1 1.2 1.3点，遂调整方向为 排查方向二 排查方向二：跳过虚拟机环境，直接去解决 插入U盘 设备管理器中能够看到设备，但“我的电脑” 中不显示目标盘符的问题，按照如下步骤进行操作，操作到 步骤4 时遇到 错误提示：“系统找不到指定文件”，在 步骤3 中观察U盘分区情况时发现 U盘并不是一整块完整的分区，而是被分成了一大两小3块分区，想到有可能是之前 U盘 有做winpe原因，决定完全格式化U盘再试 右键点击“我的电脑”图标，点击弹出菜单中的管理选项 来到计算机管理页面后，点击左侧的存储选项，将其展开后，点击下方的磁盘管理选项 在右侧的页面中可以看到电脑中所有的磁盘信息 在其中找到 目标U盘，并点击鼠标右键，然后点击弹出菜单中的 更改驱动器号和路径选项 在更改驱动器号和路径窗口中，根据喜好设置一个驱动器号，选中后点击下方的确定按钮 回到计算机页面，查看是否有 目标U盘 盘符，如果没有的话，就右键空白处，选择刷新页面即可 排查方向三：完全格式化U盘重建分区 鉴于mac物理机速度更快，直接在 mac物理机上下载 DiskGenius（绿色版），再复制到 windows虚拟机中 打开DiskGenius，删除U盘所有分区（删除所有分区 U盘内容将被全部删除） 后重建成一个分区 操作完成后重新 拔插U盘 --> “我的电脑”中成功显示 目标U盘，此问题解决 不同系统下生成目录树的方法： mac 系统命令行生成目录树的方法 tree -I node_modules --dirsfirst ，这个命令的意思是，不显示 node_modules 路径的文件，并且以文件夹在前的排序方式生成目录树。如果报没有找到 tree 命令的错，安装 tree 命令行 brew install tree 即可 brew homebrew，简称brew 非官方介绍及基本使用 及 https://blog.csdn.net/pyufftj/article/details/83102530 brew install 和 brew cask install 的关系 windows 系统在目标目录下使用 tree /f 1.txt 即可把当前目录树生成到一个新文件 1.txt 中 翻墙服务器搭建 "},"doc/ProjectExperience/ProjectExperience.html":{"url":"doc/ProjectExperience/ProjectExperience.html","title":"项目经验","keywords":"","body":"暗锚 需求背景： nav fixed定位在最顶端，nav-item使用的a标签，通过锚点实现 点击nav-item跳转对应楼层 fixed定位完全脱离文档流，导致锚点跳转时 楼层部分内容会被nav覆盖，被覆盖楼层的高度 与nav高度相同 解决方案： 在需要跳转到的 标签容器 中加上一个暗锚，并定位到距离顶端的top负距离值（nav高度），点击nav-item跳转对应楼层定位到暗锚时，就会自动空出一段距离了。 关键代码 /* md会识别html代码，样式会生效 */ /* .nav { position: fixed; top: 0; height: 80px; } .hiddenHash { position: relative; top: -80px; } */ 第一 第二 第三> 第一内容 第二内容 第三内容 ES6 模版字符串中 使用if{}else{}条件判断语句 解决方案：使用IIFE（Immediately-Invoked Function Expression 立即调用函数表达式） 注意事项： 结果字符串 作为return的值返回 如果return的是一个动态数据，记得使用``，如果使用''会被直接输出为字符串 代码如下 const html = ` 1 2 3 ${ (function () { if (XXXXXXXXX) { return `动态数据`; } else { return '静态数据'; } })() } ` 双11抽奖活动动效 使用css3 animation实现（本需求只用到了 animation-name、animation-duration、animation-timing-function 和 animation-iteration-count） animation: [animation-name/动画名称] [animation-duration/动画时间] [animation-timing-function/动画如何完成一个周期] [animation-delay/动画延时] [animation-iteration-count/动画播放次数] [animation-direction/指定是否应该轮流反向播放动画] [animation-fill-mode/规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式] [animation-fill-mode/指定动画是否正在运行或已暂停]; animation-timing-function取值 linear [动画从头到尾的匀速] ease [默认。动画以低速开始，然后加快，在结束前变慢] ease-in [动画以低速开始] ease-out [动画以低速结束] ease-in-out [动画以低速开始和结束] cubic-bezier(n,n,n,n) [在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值] .wrap { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); /* 等同于 transform: translateX(-50%) translateY(-50%); */ } .container { position: relative; width: 510px; height: 340px; padding: 0; border: 1px solid black; border-radius: 50px; margin: 0; margin-bottom: 10px; list-style: none; overflow: hidden; } .ball { position: absolute; width: 95px; height: 95px; border-radius: 50%; text-align: center; line-height: 95px; } /* 红橙黄绿蓝靛紫 天蓝 黑棕金银粉*/ .ball1 { top: 166px; left: 0px; background-color: red; } .ball2 { top: 153px; left: 72px; background-color: orange; } .ball3 { top: 170px; left: 155px; background-color: yellow; } .ball4 { top: 160px; left: 253px; background-color: green; } .ball5 { top: 110px; left: 280px; background-color: blue; } .ball6 { top: 175px; left: 323px; color: #fff; background-color: indigo; } .ball7 { top: 180px; left: 414px; background-color: skyblue; } .ball8 { top: 240px; left: 40px; background-color: black; } .ball9 { top: 250px; left: 120px; background-color: brown; } .ball10 { top: 245px; left: 200px; background-color: silver; } .ball11 { top: 250px; left: 275px; background-color: gold; } .ball12 { top: 250px; left: 360px; background-color: pink; } .ball-animation { animation-duration: 1.5s; animation-timing-function: linear; animation-iteration-count: infinite; } .ball1-keyframes { animation-name: ball1Keyframes; } .ball2-keyframes { animation-name: ball2Keyframes; } .ball3-keyframes { animation-name: ball3Keyframes; } .ball4-keyframes { animation-name: ball4Keyframes; } .ball5-keyframes { animation-name: ball5Keyframes; } .ball6-keyframes { animation-name: ball6Keyframes; } .ball7-keyframes { animation-name: ball7Keyframes; } .ball8-keyframes { animation-name: ball8Keyframes; } .ball9-keyframes { animation-name: ball9Keyframes; } .ball10-keyframes { animation-name: ball10Keyframes; } .ball11-keyframes { animation-name: ball11Keyframes; } .ball12-keyframes { animation-name: ball12Keyframes; } /* 放开ul的overflow: hidden就会发现keyframes中ball的tanslate是随意写的 */ @keyframes ball1Keyframes { 0% { transform: translate(300px, 230px); } 20% { transform: translate(200px, -100px); } 40% { transform: translate(50px, 230px); } 60% { transform: translate(300px, -50px); } 80% { transform: translate(200px, 240px); } 100% { transform: translate(0px, 0px); } } @keyframes ball2Keyframes { 0% { transform: translate(300px, -120px); } 10% { transform: translate(250px, 130px); } 30% { transform: translate(-50px, -120px); } 50% { transform: translate(0px, 140px); } 80% { transform: translate(300px, -180px); } 100% { transform: translate(0px, 0px); } } @keyframes ball3Keyframes { 0% { transform: translate(70px, -290px); } 25% { transform: translate(320px, 0px); } 50% { transform: translate(-20px, -290px); } 80% { transform: translate(290px, 0px); } 100% { transform: translate(0px, 0px); } } @keyframes ball4Keyframes { 0% { transform: translate(50px, 250px); } 12% { transform: translate(-150px, -30px); } 30% { transform: translate(-140px, 260px); } 60% { transform: translate(-10px, -30px); } 80% { transform: translate(-20px, 260px); } 100% { transform: translate(0px, 0px); } } @keyframes ball5Keyframes { 0% { transform: translate(-50px, -170px); } 22% { transform: translate(150px, 145px); } 46% { transform: translate(200px, -115px); } 80% { transform: translate(-100px, 145px); } 100% { transform: translate(0px, 0px); } } @keyframes ball6Keyframes { 0% { transform: translate(260px, 40px); } 15% { transform: translate(-80px, -260px); } 30% { transform: translate(-40px, 40px); } 45% { transform: translate(100px, -290px); } 60% { transform: translate(-80px, -280px); } 75% { transform: translate(10px, 40px); } 100% { transform: translate(0px, 0px); } } @keyframes ball7Keyframes { 0% { transform: translate(-60px, -170px); } 20% { transform: translate(90px, 160px); } 40% { transform: translate(-220px, -140px); } 60% { transform: translate(160px, -60px); } 80% { transform: translate(-100px, -100px); } 100% { transform: translate(0px, 0px); } } @keyframes ball8Keyframes { 0% { transform: translate(140px, -120px); } 20% { transform: translate(-140px, 40px); } 40% { transform: translate(-180px, -240px); } 60% { transform: translate(100px, 50px); } 80% { transform: translate(-180px, -220px); } 100% { transform: translate(0px, 0px); } } @keyframes ball9Keyframes { 0% { transform: translate(-300px, -180px); } 30% { transform: translate(-350px, 120px); } 60% { transform: translate(-100px, -200px); } 80% { transform: translate(-200px, 100px); } 100% { transform: translate(0px, 0px); } } @keyframes ball10Keyframes { 0% { transform: translate(-300px, -270px); } 15% { transform: translate(20px, -220px); } 30% { transform: translate(-350px, 10px); } 50% { transform: translate(0px, -150px); } 75% { transform: translate(-300px, -300px); } 100% { transform: translate(0px, 0px); } } @keyframes ball11Keyframes { 0% { transform: translate(-270px, -70px); } 32% { transform: translate(-320px, 220px); } 60% { transform: translate(10px, -10px); } 80% { transform: translate(-260px, 220px); } 100% { transform: translate(0px, 0px); } } @keyframes ball12Keyframes { 0% { transform: translate(-370px, -70px); } 32% { transform: translate(-120px, 220px); } 60% { transform: translate(10px, -10px); } 80% { transform: translate(-260px, 220px); } 100% { transform: translate(0, 0); } } 1 2 3 4 5 6 7 8 9 10 11 12 begin lottery stop lottery $(\"#blBtn\").click(function() { $(\".ball\").each((index, item) => { $(item).addClass(`ball-animation ball${index+1}-keyframes`); }); }); $(\"#slBtn\").click(function() { $(\".ball\").each((index, item) => { $(item).removeClass(`ball-animation ball${index+1}-keyframes`); }); }); event.target 和 event.currentTarget 传送门 currentTarget始终是监听事件者，而target是事件的真正发出者 this、currentTarget和target 在事件处理程序内部，this始终全等于currentTarget的值 如果直接将事件处理程序是被注册在 目标元素上，则this、currentTarget和target三者的值全等 在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素，即事件捕获（事件的传递过程）；然后，该事件会随着DOM树的层级路径，由子节点向父节点进行层层传递，直至到达document，即事件冒泡（事件的响应过程） 事件委托 事件委托就是利用事件冒泡机制，指定一个事件处理程序，来管理某一类型的所有事件 帮助理解的生活场景：公司的员工们经常会收到快递。为了方便签收快递，有两种办法：一种是快递到了之后收件人各自去拿快递；另一种是委托前台MM代为签收。很显然，第二种方案更为方便高效，同时这种方案还有一种优势，那就是即使有新员工入职，前台的MM都可以代替新员工签收快递 为什么要用事件委托 例举个场景：ul中包含n个li，要给每个li注册相同click处理程序，如果单独去给每个li注册事件，需要获取n次dom元素、注册多个事件处理程序（js函数），这两点将引发重绘和重排、增加内存占用，直接影响到页面的整体运行性能；而使用事件委托，只需要给ul元素注册事件 前端模块规范（共三种）：CommonJs、AMD 和 CMD 传送门 CommonJs 是服务器端模块的规范，由Node推广使用 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象，require 是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口；然而在浏览器端，加载 JavaScript 最佳、最容易的方式是在 document 中插入 script标签。但脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载 // math.js exports.add = function() { var sum = 0, i = 0, args = arguments, l = args.length; while (i AMD 是 RequireJS 在推广过程中对模块定义的规范化产出 AMD是 \"Asynchronous Module Definition\"的缩写，意为\"异步模块定义\"，依赖关系前置,在定义模块的时候就要声明其依赖的模块 define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ... }) CMD 是 SeaJS 在推广过程中对模块定义的规范化产出 CMD 是 “Common Module Definition”的缩写，意为\"通用模块定义\"，按需加载依赖,只有在用到某个模块的时候再去require define(function(require, exports, module) { var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... }) 硬编码 背景：前端中通常会出现一些 涉及业务方面的固定值，有些时候是通过常量被直接写死在逻辑代码中的，虽然从短期来看确实解决了交付代码的压力；但是从长期来看，这样的编码方式并不适应业务需求的变更，不够灵活 何谓硬编码：最简单、最直接的理解就是将一些在代码运行之前就确定好了的、可以变化的固定值写死在代码中，后续若想更改的话，只能是重新修改源代码和重新编译、构建后才会生效，这种编码过程就是硬编码。网络的解释是这样的：硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同 e.g. 国庆、双11抽奖活动中的 活动id、添加收获地址跳转链接等值都是通过常量的方式定义在代码中的 解决方案：涉及业务方面的固定值 可以 通过调用接口获取 || 构建后作为静态资源存放于服务端代码中的 也可以通过资源配置文件从服务端读取（苏宁礼遇wap） 如何声明一个 包含换行的 String变量 --> 适用ES6字符串模版 const str1 = '1换行2换行3'; // Uncaught SyntaxError: Invalid or unexpected token （有报错，故用中文替换的 回车换行） const str2 = `1 2 3`; console.log(str2);;; // '1\\n2\\n3' 电梯导航 Document *{margin: 0; padding: 0;} .nav-container { position: fixed; left: 0; top: 20%; width: 50px; } .nav-item { box-sizing: border-box; width: 50px; height: 50px; text-align: center; line-height: 50px; color: #FFF; cursor: pointer; } .nav-item.active { border: 2px solid #FFF; } .header { width: 100%; height: 300px; margin-bottom: 20px; background: hotpink; } .floor { width: 100%; height: 400px; margin-bottom: 20px; } .footer { width: 100%; height: 300px; background: hotpink; } 1 2 3 4 5 6 7 $(function(){ //给导航 和 楼层上色：红橙黄绿蓝靛紫 const colorArr = ['red','orange','yellow','green','blue','cyan','purple']; for(i = 0; i = (floorOffsetTopArr[i] - 320) && windScrollTop DOM事件绑定 与 箭头函数 DOM事件绑定中，如果回调函数中使用了 this 来获取当前注册的DOM元素（事件源），那么回调函数就不能使用剪头函数，因为箭头函数中 this 会向函数的上一层查找 页面有H5、PC双端，两者的访问链接不同：在移动端打开PC链接 自动跳转至 H5链接，在PC端打开H5链接 自动跳转至 PC链接 两者用“!“可以相互转化，检索全网 答案也是参差不齐，以下代码片段摘自 实际上线项目，笔记就以实际上线项目的代码为准吧 PC (function () { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == \"ipad\"; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == \"iphone os\"; var bIsMidp = sUserAgent.match(/midp/i) == \"midp\"; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == \"rv:1.2.3.4\"; var bIsUc = sUserAgent.match(/ucweb/i) == \"ucweb\"; var bIsAndroid = sUserAgent.match(/android/i) == \"android\"; var bIsCE = sUserAgent.match(/windows ce/i) == \"windows ce\"; var bIsWM = sUserAgent.match(/windows mobile/i) == \"windows mobile\"; if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { location.href = `${H5访问链接}`; } })(); H5 (function () { if (!navigator.userAgent.match( /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i ) ) { location.href = `${PC访问链接}`; } })(); CSS媒体查询 CSS 媒体查询media screen 中width的值代表页面的可用宽度，获取方法：window.innerWidth CSS2 既然CSS2可以实现媒体查询 那为什么不用这个方法呢，CSS2媒体查询最大的弊端就是它会增加页面http的请求次数，增加了页面负担，我们用CSS3把 媒体查询样式 都写在一个文件里面才是最佳的方法 上面将设备分成3种，分别是宽度大于800px时，应用 styleA ，宽度在600px到800px之间时应用 styleB ，以及宽度小于600px时应用 styleC 。那假如宽度正好等于800px时该应用哪个样式？是 styleB，因为前两条表达式都成立，按CSS默认优先级规则后者覆盖了前者。因此，为了避免冲突，这个例子正常情况应该这样写： 备注：demo1 和 demo2的区别 demo1：视口宽度在 media 设置的尺寸下 当前 link 引入的 style 才会生效，media写法使得 只有一份 style 生效，不存在不同 link 引入的 style 之间的相互层叠 demo2: 视口宽度在 media 设置的尺寸下 当前 link 引入的 style 就会生效，media写法使得 可能有多份 style 同时生效，存在不同 link 引入的 style 之间的相互层叠 CSS3 加入meta标签 width=device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 语法：@media mediatype and | not | only (media feature) { css-code; } mediatype取值（目前项目中最常使用到的还是 screen） all 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 print 手持设备 projection 打印预览 screen 彩屏设备 speech '听觉'类似的媒体类型 tty 不适用像素的设备 tv 电视 关键字 and not：用来排除某种制定的媒体类型 only：用来定某种特定的媒体类型 // styleA.css代码 @media screen and (max-width: 800px){ // styleB.css代码 } @media screen and (max-width: 600px){ // styleC.css代码 } 页面TDK title title title，就是浏览器标签上显示的内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高 description description，和上面的keywords一样，是用户不查看源代码看不到的，而且也是对于一个网页的简要内容概况。不同的是，keywords是由几个词语的组成的，而description则是完整的一句话。description一般不超过150个字符，描述内容要和页面内容相关 keywords keywords，是用户不查看源代码看不到的。主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此keywords的每个词都要能在内容中找到相应匹配，才有利于排名。keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。为什么用英文上文已经说过。而且，尽量将重要的关键字靠前放，因为靠后的关键字排名较差，除非你站有很高的权重 结：TDK名义上要使用英文，但我查看了下国内知名电商网站 jd、taobao 也都是使用的中文，so 入乡随俗吧 jd PC官网TDK 京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！ taobao PC官网TDK 淘宝网 - 淘！我喜欢 css适配iPhoneX屏幕安全区（需求后来fixed底部导航并未做iphoneX以上机型安全区处理，之前电商项目有处理但并未看细节，相当于此点并进行过未实战） 场景：iPhoneX对比其他机型，屏幕顶部变成了留海屏，底部取消了物理按键改成了小黑条，这种变化导致了web开发中页面上新的适配问题。比如一些需要贴在底部的按钮，和呼起的tabBar和底部弹出框，在iphoneX上就会出现被小黑条遮挡内容，或者页面上出现白色空隙的问题 viewport-fit：iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值： contain: 可视窗口完全包含网页内容（左图） cover：网页内容完全覆盖可视窗口（右图） auto：默认值，跟 contain 表现一致 env：iOS11 新增特性，Webkit 的一个 CSS 函数，用于向 CSS 插入用户代理定义的变量设定安全区域与边界的距离，有四个预定义的变量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 注意：env()必须配合 viewport-fit=cover 使用，我们最常用的就是 safe-area-inset-bottom, 这个代表着不被小黑条遮挡的安全距离 /* 贴底元素 */ .container position: absolute; bottom: 0; padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS = 11.2 */ ... } 移动开发的HTML5页面点击按钮出现闪烁或黑色背景解决方案 场景：节日活动推广落地页面，PC、wap双端，页面仅有多个点击效果相似的按钮 基本没有其他交互，时间紧张 为尽快上线，协调UI将设计稿切分成一块儿块儿的图片，前端用div布局 用css将展示内容作为背景图进行设置，涉及到 点击按钮 的部分，前端使用相同 宽、高、圆角的无边框、透明div进行定位覆盖，点击事件绑定在 覆盖在按钮的div上：pc浏览器模拟移动端仿真模式 || 真机上 点击按钮（div）出现闪烁 或 黑色背景 pc: https://nce.koolearn.com/zhuanti/oral_pc wap: https://nce.koolearn.com/zhuanti/oral_wap 解决方案 设置html || * 的 -webkit-tap-highlight-color样式 -webkit-tap-highlight-color 是一个没有标准化的属性，能够设置点击元素 || 链接时出现的高亮颜色。显示给用户的高光是他们成功点击的标识，以暗示他们点击的元素 浏览器兼容：webkit/safari, Blink/Chrome 随意查阅了下m.jd.com || m.taobao.com网站css，都有对“-webkit-tap-highlight-color”的设置 *{ -webkit-tap-highlight-color: transparent; } jQuery常用api Document * { padding: 0; margin: 0; } ul { list-style: none; } li { width: 500px; height: 50px; } .box01 { background-color: red; } .box02 { background-color: orange; } .box03 { background-color: yellow; } .box04 { background-color: green; } // jQuery 事件绑定 || 事件委托方式：多个元素绑定相同事件、同时绑定多个事件 // 多个事件源之间使用“,”分割，多个事件之间使用\" \"分割 // 事件绑定 $(\".box01, .box02\").on(\"click mouseover\", function(event) { console.log(`事件绑定：${event.target.className} 的 ${event.type} 事件触发了`); }); // 事件委托 $(\"body\").on(\"click mouseover\", \".box03, .box04\", function(e) { console.log(`事件委托：${event.target.className} 的 ${event.type} 事件触发了`); }); // jQuery 判断元素上是否包含某个class $(\"li\").on(\"mouseover\", function() { if ($(this).hasClass(\"box01\")) { console.log(\"mouseover box01\") } else if ($(this).hasClass(\"box02\")) { console.log(\"mouseover box02\") } else if ($(this).hasClass(\"box03\")) { console.log(\"mouseover box03\") } else if ($(this).hasClass(\"box04\")) { console.log(\"mouseover box04\") } else {} }); /* * $.extend([deep], target, object1 [, objectN]) * 用于将一个或多个对象的内容合并到目标对象 * params： * deep：可选。 Boolean类型 指示是否深度合并对象，默认为false。如果该值为true，且多个对象的某个同名属性也都是对象，则该\"属性对象\"的属性也将进行合并 * target：合并到的目标对象，原值会被修改：如果不想改变被合并的对象 可以将target定义为“{}”，将结果再赋值给变量即可 */ var infoPart1 = { height: '180cm', weight: '100kg', age: '29', local: { province: 'TJ', } } var infoPart2 = { gender: 'male', local: { country: 'China', } } var info = $.extend(true, {}, infoPart1, infoPart2); console.log(info); /* { height: '180cm', weight: '100kg', age: '29', gender: 'male', local: { province: 'TJ', country: 'China' } } */ /* 其他常用 jQuery方法 小汇： end：取消当前的jQuery对象，返回前面的jQuery对象 eq(n)：获取第n个元素，结果为 jQuery对象 get(n)：获取第n个元素，结果为 Dom对象 */ toast弹窗实现 transition: [transition-property/css属性] [transition-duration/动画时间] [transition-timing-function/动画如何完成一个周期] [transition-delay/动画延时] transition 和 animation的区别： transition 是令一个或多个可以用数值表示的css属性值发生变化时产生过渡效果。 animation 则是属于关键帧动画的范畴，它本身被用来替代一些纯粹表现的javascript代码而实现动画 transform：变形、形变 针对translate、translateX（X轴平移）、translateY（Y轴平移）、rotate（旋转）、scale（缩放）、skew（扭曲） Document #toast1, #toast2 { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 150px; border-radius: 10px; text-align: center; font-size: 12px; line-height: 40px; color: #fff; background: rgba(0, 0, 0, .7); } toast btn1 toast btn2 toast btn3 $(\"body\") .on(\"click\", \"#toastBtn1\", function() { $(\"#toast1\").text(\"hello, i'm toast1.\"); $(\"#toast1\").fadeIn().delay(1000).fadeOut(); }) .on(\"click\", \"#toastBtn2\", function() { $(\"#toast2\").text(\"hello, i'm toast2.\").show(); setTimeout(() => { $(\"#toast2\").hide(); }, 1000); }) .on(\"click\", \"#toastBtn3\", function() { ToastFn(\"hello, i'm toast3.\", 1000); // 封装成了函数 function ToastFn(msg, duration) { duration = isNaN(duration) ? 3000 : duration; var toast = document.createElement('div'); toast.innerHTML = msg; toast.style.cssText = ` position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: opacity .5s ease-in-out; width: 150px; border-radius: 10px; text-align: center; font-size: 12px; line-height: 40px; color: #fff; background: rgba(0, 0, 0, .7); `; document.body.appendChild(toast); // 第一个setTimeout：duration后添加渐入渐出样式，同时opacity设为0，toast元素消失 setTimeout(function() { toast.style.opacity = '0'; /* 第二个setTimeout：虽然上面给 toast元素 设置了opacity为0，元素从页面上消失了 但是标签还在html中，多次点击会向body中append多个toast元素，所以第二个setTimeout的目的在于 在宏任务中移除 toast元素：题外话，如果不使用setTimeout直接移除，渐入渐出的样式效果就无法表现出来 */ setTimeout(function() { document.body.removeChild(toast); }); }, duration); } }); Rem布局 根据元素在视觉稿中的比例等比缩放找到 如下关系： 视觉稿元素尺寸 / 视觉稿画布宽度 = (rem 值 * HTML 元素的 font-size) / 布局视口宽度 = rem 值 * (HTML 元素的 font-size / 布局视口宽度) = rem 值 / (布局视口宽度 / HTML 元素的 font-size) // 后面三个为 简单地改变运算顺序 如果： 布局视口宽度 / HTML 元素的 font-size = 定值 N // 上面关系式中最后一个等号后面的被除数 即： 视觉稿元素尺寸 / 视觉稿画布宽度 = rem 值 / (布局视口宽度 / HTML 元素的 font-size) = rem 值 / N 就可以用同一份 CSS 代码实现在任何设备中自适应 视觉稿元素尺寸 / 视觉稿画布宽度 = rem值 / N ==> rem 值 = N * (视觉稿元素尺寸 / 视觉稿画布宽度) 我们只要确定一个 N 值，再完成两步，即可实现自适应： 动态设置 HTML 元素的 font-size 布局视口宽度 / HTML 元素的 font-size = 定值 N ==> HTML 元素的 font-size = 布局视口宽度 / N document.documentElement.style.fontSize = document.documentElement.clientWidth / N + 'px'; 将视觉稿中导出的元素 CSS 像素值转成 rem 单位: rem 值 = N * (视觉稿元素尺寸 / 视觉稿画布宽度) 假如视觉稿画布宽度是 750px，为了便于 rem 值的计算可以设置 N = 7.5， 这样只需要将视觉稿中的尺寸值除以 100 就可以得到 rem 单位的 CSS 像素值 rem 值 = N * (视觉稿元素尺寸 / 视觉稿画布宽度) = 7.5 * (视觉稿元素尺寸 / 750) = 视觉稿元素尺寸 / 100 // 为页面html动态设置font-size值 (function (doc, win) { var htmlEle = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', reCalc = function () { var clientWidth = htmlEle.clientWidth; if(clientWidth > 750){ clientWidth = 750; } if (!clientWidth) return; htmlEle.style.fontSize = clientWidth / 7.5 + 'px'; }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, reCalc, false); reCalc(); })(document, window); 获取图片宽高 // 图片来源于 百度图片，在浏览器新标签页打开 大小为 704KB，非读缓存 用时 374ms const img = document.createElement(\"img\"); // || const img = new Image(); img.src = \"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2020-04-07%2F5e8c1c1f397b9.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641609272&t=8166b79fc50ddaf648982d4171ad040f\"; // 错误方式一：直接输出 // console.log(`width: ${img.width}; height: ${img.height}`); // 输出结果为：width: 0; height: 0 // 说明：图片未被加载，获取的 宽、高 都是0 // 正确方式一：在图片所有相关数据被加载后触发 /* img.onload = function() { console.log(`from onload, width: ${img.width}; height: ${img.height}`); } */ // 输出结果为：from onload, width: 1920; height: 1080 // 说明：onload在图片相关数据被加载后触发 // 正确方式二：我们知道有些图片虽然没有完全down下来，但是已经先有了占位符，然后一点一点的加载。既然有占位符那应该是请求图片资源服务器响应后返回的。问题是 服务器什么时候响应并返回宽高的数据呢，使用一个 间歇定时器来循环判断 图片宽高是否已经能读取的到 /* const check = function() { if (img.width || img.height) { console.log(`from check, width: ${img.width}; height: ${img.height}`); clearInterval(interval); } } const interval = setInterval(check, 10); */ // 对比正确方式一 和 方式二 两者的用时 const startDate = new Date().getTime(); const check = function() { if (img.width || img.height) { const diff = new Date().getTime() - startDate; console.log(`from check, width: ${img.width}; height: ${img.height}, 用时${diff}ms`); clearInterval(interval); } } const interval = setInterval(check, 10); img.onload = function() { const diff = new Date().getTime() - startDate; console.log(`from onload, width: ${img.width}; height: ${img.height}, 用时${diff}ms`); } // from check, width: 1920; height: 1080, 用时90ms // from onload, width: 1920; height: 1080, 用时353ms（每次请求事件略有出入，不必计较） 国内大型网站提供的 IP API接口调用方法 项目代码中看到的 已经用到了的：http://pv.sohu.com/cityjson?ie=utf-8（代码中使用的 jsonp 请求方式） getUserIp() { $.ajax({ url: 'https://pv.sohu.com/cityjson?ie=utf-8', type: 'get', dataType: 'jsonp' }).always(() => { if (window.returnCitySN) { // todo code } }); } 伪类 伪元素 伪类 伪类是 样式选择器 的一种，用于选择处于特定状态的元素，表现与类名相似：能够减少多余的类，让代码更灵活、更易于维护，伪类开头为 单冒号: 关于 :link :visited :hover :active 伪元素需要注意的点： css 代码书写顺序按照 love hate即可：link o visited e hover active te 如果url被点击访问过，访问过的记录就会在浏览器缓存中存在，元素展示的就会是 :visited 的样式，刷新页面||重启浏览器都是无效的，只有清除浏览器缓存才能回到 :link 的样式 亲测“开发者工具 Application --> Storage --> Clear site data”无效哈，还是得去“设置 --> 隐私设置和安全 --> 清除浏览数据”中去处理 伪类 作用 :link 将样式添加到未被访问过的链接（a标签） :visited 将样式添加到已被访问过的链接（a标签） :hover 将样式添加到鼠标悬浮的元素（a标签） :active 将样式添加到**处于激活状态（点击瞬间 点击未松开）**的元素（a标签） :focus 将样式添加到获取焦点的元素（表单元素） :first-child 将样式添加到 一组兄弟元素中的第一个元素 :nth-child(n) 将样式添加到 一组兄弟元素中的第n个元素 :last-child 将样式添加到 一组兄弟元素中的最后一个元素 Document /* 1. 未被点击过时 显示的颜色，表示链接在正常情况下（即页面刚加载完成时）显示的颜色 */ .a-ele:link { color: red; } /* 4. 已经 点击 过 */ .a-ele:visited { color: green; } /* 2. 鼠标悬浮 */ .a-ele:hover { color: orange; } /* 3. 处于激活状态，点击 按下没有松开 */ .a-ele:active { color: yellow; } testA 伪元素 伪元素 表现如同向标记文本中加入全新的HTML元素，而不是 像伪类 向现有的元素上应用类名，伪元素开头为 双冒号:: 注意事项： 伪元素相当于 被选中元素 的子元素 伪元素在元素默认为inline，想要设置伪元素宽高需要手动对 display 进行修改 伪元素列表属性中 content 必不可少，即使内容为空也需要写成孔串（需使用 双引号） 伪元素content除了可以设置为文字之外，还可以设置为图片，例如p:before{content:url(icon.gif);} 伪元素目前已经得到IE8及以上浏览器，可以放心使用 伪元素 作用 ::first-letter 将样式添加文本的首字母 ::first-line 将样式添加到文本的首行 ::before 在某元素之前插入某些内容 ::after 在某元素之后插入某些内容 .square{ position: relative; width: 80px; height: 80px; border: 2px #000000 solid; background-color: #FFF; } .square::before{ content: \"\"; position: absolute; /* 浏览器控制台发现： 行内元素如果设置了 “position: absolute || fixed;” || “float: left || right;” display 值就会变成了 block */ z-index: 2; left: 20%; bottom: -28px; width: 0px; height: 0px; /* border-width: 15px; border-style: solid; border-color: #FFF transparent transparent transparent; */ border: 15px solid transparent; border-top-color: #FFF; } .square::after{ content: \"\"; position: absolute; z-index: 1; left: 20%; bottom: -30px; width: 0px; height: 0px; /* border-width: 15px; border-style: solid; border-color: #000 transparent transparent transparent; */ border: 15px solid transparent; border-top-color: #000; } Android手机微信环境 无法打开 h5页面中的m3u8视频 解决方案： 启动微信的X5内核，使用X5内核进行页面渲染 微信环境访问“http://debugmm.qq.com/?forcex5=ture”即可 使用 hls.js，细节原理浅尝辄止，传送门 var video = document.getElementById('J_video'); var videoSrc = 'http://ivi.bupt.edu.cn/hls/cctv2hd.m3u8'; if (Hls.isSupported()) { var hls = new Hls(); hls.loadSource(videoSrc); hls.attachMedia(video); } else if (video.canPlayType('application/vnd.apple.mpegurl')) { video.src = videoSrc; } video.play(); ul 子元素过多时，显示水平滚动条 Document /* 使用flex布局 */ /* li 样式如果不加 flex: none; 所有的 li 会被自动压缩宽度，以适配当前容器宽度 */ /* ul { display: flex; width: 300px; padding: 0; border: 1px solid hotpink; margin: 200px auto 0; overflow-x: scroll; } li { flex: none; width: 80px; height: 60px; line-height: 60px; text-align: center; list-style: none; } */ /* 常规布局，ul 样式添加 white-space: nowrap; */ /* ul 样式如果不加 font-size: 0; li 之间会有换行符间隙 */ ul { width: 300px; padding: 0; border: 1px solid hotpink; margin: 200px auto 0; font-size: 0; white-space: nowrap; overflow-x: scroll; } li { display: inline-block; width: 80px; height: 60px; font-size: 12px; line-height: 60px; text-align: center; list-style: none; } /* 以上两种方式均达到了效果，但 mac下滚动条表象 略有不同（window下没测），不再深究 */ 1 2 3 4 5 const colorArr = ['red','orange','yellow','green','blue']; for(let i = 0; i 相对协议 浏览器默认是不允许在 https 里面引用 http 资源的，如果用户这么做了，一般都会弹出提示框 如果你的网站同时准备了 https 资源和 http 资源，那么，可以使用相对协议 帮助你实现当网站引入的都是 http 资源，网站域名更换为 https 后的无缝切换 具体使用方法为： div { background-image: url(//domain/x.png); } 顶级域名（Top-level Domain Name）、二级域名、三级域名... 顶级域名就是 一级域名，e.g.(exempli gratia) .cn | .com | .org | .edu | .gov | .net n级域名 就是在 n-1级域名前 追加一级 局部概念 www.jd.com：com 为顶级域名，jd 为二级域名，www 为三级域名 整体概念 jd.com 是一个二级域名，www.jd.com 是一个三级域名 "},"doc/Internet&&System/Internet&&System.html":{"url":"doc/Internet&&System/Internet&&System.html","title":"网络和系统","keywords":"","body":"运营商光猫路由器改桥接 背景：运营商提供的宽带设备 集 光猫（调制解调器，互转光信号和电信号的设备） 和 路由器功能于一体，硬件配置相对较差：装维师傅给用户安装宽带时，出于自己更省心，同时方便用户的角度（不用记住宽带的账户密码，因为直接内置到光猫里面了，用户回家不需要自己单独购买路由器），会直接用上光猫的路由功能。对于大部分入门用户，家里也就三五个手机的情况，倒也够用了，但是如果家里设备非常多，二三十个联网设备以上，这个光猫的路由性能可能就不够用了，网络可能就会经常出现卡顿和中断的情况。还有就是如果用 Mesh 组网，赠送的光猫路由器 可能不符合Mesh 路由器产品的网络拓扑关系：这时候就要考虑，把光猫从路由模式改成桥接模式，让光猫只用来做光信号和电信号的转换，不做任何网络相关的功能（路由+DHCP），把这部分功能交给性能更强大的路由器来完成 光猫路由模式改成桥接模式 获取光猫 超级用户名密码（光猫背面有打印 普通管理员 账号密码，只能看到基本的配置页面，操作权限有限），获取渠道一般有以下三种： 根据运营商 和 光猫型号在网络上进行查询 使用普通管理员账密登陆，看能否找到telnet开关，如果能成功打开telnet就可以在windows电脑上通过telnet客户端连接上路由器，查询到相关账密 电话联系运营商，可以 以多设备同时连接掉线为由 报修，待装维师傅回联时索要超密 “路由模式” 更改连接模式为 “桥接模式”，需注意以下几点： 光猫中可能同时存在 几个连接名称，目标修改项 是名称中带有“INTERNET”字样的那个 变更“路由模式”前先将页面中的所有配置参数截图保存，以备 路由器拨号 || 光猫“桥接模式”改“路由模式”使用 如果页面显示的 连接模式 不是 select option的结构，只能先删除“路由模式”，新建“桥接模式” 连接光猫 到 自己的路由器，进行拨号上网 软路由简介 及 家庭网络中 软路由三种组网方式 大乖家 家庭网络 当前组网拓扑 目前存在的问题点 光猫未设置桥接，20220521如果桥接光猫（只负责光电信号转化，主路由负责PPPoE拨号） 使用京东云无线宝进行拨号上网（或者打开光猫的DMZ || UPnP），会发挥出无线宝的最大特性 霸占带宽（300M宽带）影响其他接入网络设备的上网体验：后续考虑桥接光猫 用一台主机做软路由，安装exsi虚拟机系统，虚拟出routesOS（ROS）主路由、OpenWRT旁路网关，其他硬路由作为AP接入 20220521京东云无线宝424749（ROM版本: JDC03-3.2.3.r1927 ） 上网方式中有 无线中继 选项，而我需要的是桥接，家中如果没有特殊需要 同时存在几个子网 想想就感觉别扭，最后上网方式选择了DHCP，工作模式中将 路由模式 切换成了 “有线”AP模式，其实这里我没理解狗东产品经理想表达的意思，AP难道不都是有线连接到上级路由的吗？！因为建房时并未对网线进行暗线预埋 又不愿意走明线（需要打孔，而且巨丑），这个AP距离上级路由（另一台无线宝）仅一台电视长度的距离（放在了电视的两侧）😅，好在使原有家庭网络得到了加强，后续考虑 能否将家里 暗线中的电话线（只有两根，如果是四根就可以直接用了）替换成网线，主路由拨号后接出交换机，其他房间接AP 补充下关于过程中碰到的问题 wifi相关的 信道 也称作通道或频段，是以无线信号作为传输载体的数据信号传送通道，2.4G频段的工作频率为2.4-2.4835GHz，这83.5MHz频带划分为13个信道，各信道中心频率相差5MHz，向上向下分别扩展11MHz，信道带宽（信道频宽）22MHz。中国采用欧洲/ETSI标准，使用1-13信道。如图所示，相近无线路由器采用相同或重叠信道会形成信道竞争关系，相互影响无线链路质量，为了有效避免信道重叠造成的相互干扰，相近无线路由器应选择互不重叠的信道工作，如（1、6、11），（1、7、13）等，但无线路由器并非只能工作在这些信道。 ![2.4Gchannel][2.4GchannelPic] ![2.4Gchannel1][2.4Gchannel1Pic] 信道推荐自动选择 早期无线路由器出厂时预设相同的信道（大多为6），因用户很少会修改信道，从而导致相互影响的情况。随着无线应用的迅速普及，无线路由器增加了信道自动选择功能，在设备启动时检测周围无线信道分布情况，选择最佳信道工作。无线信道自动选择的作用是：信道重叠会导致无线路由间相互干扰，进而影响无线传输质量，信道自动选择功能使得路由器根据周围无线环境自动设置最佳工作信道，有效避免同频干扰/竞争。 什么情况需要手动选择信道，在以下应用中，我们建议手动选择路由器的信道： 传统界面路由器在设置WDS无线桥接或多个无线路由器通过LAN-LAN级联设置漫游网络时时，建议设置固定的信道； 部分无线终端可能无法识别12或13信道，当路由器自动选择这两个信道时，无线终端无法搜索到信号，此时需要将路由器的信道固定为1-11之间。 无线干扰严重。无线信道自动选择功能在路由器启动后会根据当前的环境自动设置到最佳工作信道，直到路由器重启前，该信道都不会改变，但实际环境中，可能路由器工作过程中周围无线环境发生了变化，引起较强的无线干扰，此时需要考虑手动设置信道。 如何手动选择最佳信道 部分无线路由器支持WDS功能，在路由器界面 开启WDS 功能，扫描 周围无线信号 使用第三方软件，例如 我目前android K40上正在用的 Cellular-Z 信号强度 通常，-70dbm以上为理想的信号强度，-70dbm～-80dbm为中等信号强度，小于-80dbm为弱信号。使用Cellular-Z软件同样可以测试附近的wifi信号强度，来了个极限测试：手机直接放在路由器上 信号强度为 0dbm，但再怎么强大的wifi信号强度也不如有线连接，有条件的有线连接才是王道 不同的品牌设备之间功能存在差异，同样的功能在不同的路由器厂商间叫法也可能不同，以这次我手头上的几台路由设备为例： 20220521京东云无线宝 无线中继上网方式 会新建子网无法设置lan口ip、关闭DHCP功能，此上网模式下 只能作为二级路由使用，不能作为无线中继使用； TP-LINK路由器 开启WDS后 可以对周围的无线信号 进行扫描、桥接，官网明确指出 桥接后的wifi信道需要与主路由相同，观察TP-LINK云路由器相关型号（支持APP客户端连接配置）WDS桥接配置选项中已没有了信道项，应该是简化配置 方便用户更傻瓜式操作，SSID 和 密码可以不同，必须关闭DHCP 我理解的路由器（不包括猫）间的 AP、桥接、中继 AP： 有无线：与上级路由的连接方式为有线，AP都是有线连接 设置方式：主路由打开DHCP，子路由关闭DHCP 设置lan口为固定ip 且从属于主路由下局域网网段，有线连接 主、子路由的lan口 桥接： 有无线：特指无线桥接，与上级路由器的连接方式为无线，如果有线连接就是AP 设置方式：主路由打开DHCP配置好wifi，子路由关闭DHCP 设置lan口为固定ip 且从属于主路由下局域网网段：子路由的lan口 桥接的是 主路由的lan口 中继： 有无线：与上级路由器包括有线 和 无线连接，就是二级路由，会创建新的子网 与上级网络不同网段 主、子路由同时打开DHCP功能，有线：子路由lan口连接主路由wan口；无线中继：碰过的路由器有限，目前还真就是 京东云无线宝：子路由wan口 中继的是 主路由的lan口 总结：家庭组网中多个路由器连接 有同一个网段的需求，路由器间的连接方式参考 AP（有线连接） || 桥接（无线连接） 路由器下需要新建子网 有别于主路由下局域网网段的，路由器间连接方式参考 中继 补充光猫桥接：光猫只负责 光电信号转换，主路由负责拨号，有线连接光猫lan口与主路由wan口，与路由器间桥接的共同点是：桥接就是透传 TP-LINK[TL-WR886N]路由器固件升级，TP-LINK其他型号参考此方法在官网进行搜索 常用网站 网速测试 DNS Unix、Linux操作系统发展史 补充说明： Linux于1991年由芬兰大学生Linus开发出来，是一个类Unix系统，但是其代码不源自任何Unix版本，完全不是Unix的一个分支，而是一个开源版的模仿：耳熟能详的Ubuntu、CentOS、Debian都是Linux的发行版 linux免费 unix收费且价格昂贵 这两个操作系统如此相似 为什么企业还用unix而不用linux？ 并不是所有linux都免费，有些linux对企业用户有重要支持，如suse，红帽等，这一类对企业是收费的。现在也有很多中小企业，甚至大企业会采用linux系统作为某些服务器的系统，但是有些企业因为部分数据非常重要，或者需要更高效的管理，或者需要管理这些数据的服务器具有极强的稳定性和性能，会采用Unix作为这部分数据的服务器，而其他相对不太重要的则采用其他类型操作系统作为服务器系统。这里并不是说明Linux不能做到，而具有更复杂的原因。 Unix作为服务器系统主要有4个方面原因： Unix系统的支持厂商都是“大牛”公司，服务比较好，当然系统也相当好；（有大公司“撑腰”） Unix系统的厂商常常不但生产服务器，而且提供Unix系统，还有售后服务，包括软件与硬件方面（服务器厂商一条龙服务）；他们的系统和服务器配合更能发挥性能到极致（各方面极致体验），客户也不愿意（通常）另外选用其他系统，一是不方便，出现故障后不知道什么问题或者需要更多联系；二是各大厂商都有营销策略，他们使客户相信Unix是附赠品一样便宜，但是实际上这些厂商服务支持也能为企业谋取利益（macOS属于Unix操作系统，难怪既好用又稳定）； 传统优势。linux出现时间较晚，稳定性还未得到证明（并不是说不稳定）。Unix系统基本上自产生都是应用于服务器的系统，加上那些厂商采用绑定策略等原因，使得至今大部分服务器采用系统是Unix。这里说的服务器不是PC服务器，而是小型机等。 最后是开源的问题：软件不可能是没有缺陷的，开源软件意味着潜在的漏洞（如果存在）可能导致安全问题，因为有些人心怀鬼胎，会做坏事。不过，开源软件渐渐成熟了，事实证明，Linux正在增长。（商业闭源，安全可靠） 物理机安装 windows操作系统 找一个空闲的U盘，备份内容后制作winpe winpe推荐微PE，主打轻量、纯净，相比 老毛桃 和 大白菜 已看到更多人推荐 在I Tell You中下载 目标系统的iso镜像 解压iso镜像 拷贝至U盘 || 移动硬盘 备用 将U盘 插入 目标物理机，启动物理机进入BIOS 设置从目标U盘启动，进入到winpe系统 使用 DiskGenius 格式化物理机硬盘并理想分区 BIOS 引导方式分为 Legacy 和 UEFI，Legacy启动模式兼容性较好，在安装操作系统时可以选择32位或64位的，但是硬盘分区最大支持2TB，理论支持安装Windows所有版本的系统；而UEFI启动模式只能安装64位的操作系统，硬盘分区最大支持18EB，基本上算是无限大，相对启动速度会更快，同时为用户在BIOS中提供支持鼠标等功能的更高级的图形界面（同时 这点暂时没体会到） windows 32位操作系统适用于2G内存左右的机器，现在（20220425）的计算机硬件配置普遍过剩，4g内存应该都是丐版的存在，硬盘越做越大，对系统启动速度的要求也越来越高，所以UEFI已是主流 BIOS Legacy引导方式 对应 硬盘MBR分区表类型，UEFI引导方式 对应 硬盘GPT分区表类型：安装系统时，不同的BIOS 引导方式，在进入winpe 格式化硬盘时要注意将其转化成 对应的 分区表类型：系统安装好后不能再修改 BIOS引导方式，否则将无法正常进入系统 将 步骤3 中解压后的iso文件拷贝到 物理机非系统盘中 安装系统（直接双击exe文件安装系统的方式 还不能完全支持NT5.X的系统，详见） NTX.X中，NT 指的是Microsoft Windows New Technology，X.X是NT内核的Windows操作系统的内部版本号，Windows下NT5.X 和 NT6.X的关系如同 Mac OS 9 和 Mac OS x 的关系 方式一：通过 Windows安装器 安装系统 Windows安装文件路径 为“解压后的iso文件夹/sources/install.wim” 方式二：直接双击 解压后的iso文件夹 中的 Setup.exe 文件进行安装 过程中碰到的问题及注意点： 物理机usb接口老化，读不出U盘：PC（特指非mac）从BIOS设置从U盘启动时，如果在Boot列表中找不到 已插入的U盘，可以换个 USB口插U盘 再重启进入BIOS看 说不定就有了 U盘启动进入winpe系统后，winpe已加载至物理机内存中，U盘可以拔出 "},"doc/Mac/Mac.html":{"url":"doc/Mac/Mac.html","title":"Mac","keywords":"","body":"Finder侧边菜单中显示的Macintosh，和网上说的 OS X 系统都是什么 Macintosh，麦金塔，简称Mac 操作系统的名字经历了 Mac OS X --> OS X --> macOS（20220426） 的变化过程，代号也经历了 大型猫科动物 --> 加州地标 的变化，详见维基百科 系统的 大版本 和 代号 的关系是一一对应的，一个大版本下有多个小版本，比如我现在在用的这个 我人生中买的第一台Mac：系统版本是 macOS 10.15.7 代号 Catalina，大版本为 10.15，10.15.7 为 10.15大版本下的最后一个小版本，详见维基百科 mac之间屏幕共享 command + space 键入”屏幕共享.app”，然后输入 要连接主机的Apple ID，被连接主机收到通知 点击允许后方可连接，使用体验极佳 给mac添加右键菜单“Open With VSCode” command + n 打开 “自动操作” 应用程序，点击“新建文稿” 选择快速操作 在左侧面板选择“实用工具”；然后找到”运行 Shell 脚本“后双击，在右侧“服务”收到选定选择文件夹，位置 “Finder（访达）.app”；“运行 Shell 脚本”的面板里，Shell选择 “/bin/bash“，传递输入选择 “作为自变量”，然后修改 Shell 脚本，如图![openWithVSCode][openWithVSCodePic] 按顺序操作，复制以下内容到 Shell 脚本中for f in \"$@\" do open -a \"Visual Studio Code\" \"$f\" done Command + s 保存为 「Open With VSCode」 小插曲：保存时报Operation not permitted，查资料后得知与Mac OS升级有关，解决方案如下 左上角点击选择‘系统偏好设置’ 选择“安全性与隐私” 选择 隐私-->“完全磁盘访问权限” 点击左下角按钮获得管理员操作权限 把出问题的应用程序加到““完全磁盘访问权限””列表中 好了，现在试试在 Finder 里右键一个文件，就可以直接看到「Open With VSCode」菜单，右键一个文件夹，就可以看到「服务」-「Open With VSCode」菜单了 Mac Finder中显示、隐藏 隐藏文件 “Shift + command + 。“ || “Shift + command + .“快捷键（即无需判断中英文输入法状态） 安装非信任开发者的软件后，通过“command + space”打开，系统提示“无法打开xxx，因为无法验证开发者”，且dialog底部不包含“打开”选项 解决方案 打开Finder，左侧选中“应用程序”，在对应右侧列表中找到 目标应用程序 右键点击打开，发现dialog底部多了“打开”选项 V2RayX.app添加第二个订阅地址 保存后闪退，重启应用无反应 分析原因：当前安装的应用下载自 https://github.com/Cenmrev/V2RayX/releases，最新的Releases v1.5.1发布时间为20190214，距离当前出现问题的时间点（20220221）已有3年，期间未更新，本次添加第二个订阅地址的操作应该是 触发了某些隐藏bug 在 2.1.2 解决了app启动问题后，只添加 速鹰 的机场没问题，只添加 闪电 的机场 app又发生了闪退，且重启无反应，衰，找到病根了 解决方案： 卸载后重装 无效，百度后得知 可能与用户的遗留文件有关（卸载应用后 配置文件等并未被同步删除，重新安装app，启动后又被自动读取），还需删除以下文件 Config: ~/Library/Preferences/XXX System: ~/Library/Caches/XXX Plugins: ~/Library/Application Support/XXX Logs: ~/Library/Logs/XXX 卸载app，删除遗留文件后再次重新安装后启动成功；如果还不行就重启 重复2的操作 使用互为替代品 V2RayU（V2RayU 与 V2RayX相似，同样是基于v2ray-core封装的mac客户端） 成功安装，添加订阅后发现所有节点配置延迟都为-1无法使用，因为电脑当时无法fq 能查阅到的解决方案有限，遂放弃 iCloud 和 iCloud Drive iCloud 简介：iCloud将你的某些App（照片、日历、信息、备忘录等）的内容存储到云端并通过无线（这里指的是不使用数据线连接，而不是无线网）推送到你的其它设备（iphone、ipad、mac等） 使用方式： mac：系统偏好设置 --> Apple ID，登陆Apple账号 --> iCloud --> 勾选需要存储到云端的项 iphone：设置 --> 用户名 --> iCloud --> 勾选需要存储到云端的项 注： 不同设备需要登陆同一Apple ID iphone如何同步备忘录到iCloud： 2.2中勾选了备忘录 打开iphone中的备忘录列表，点击右上角“编辑”，选择需要同步的备忘录item，或点击左下角的“移动全部”，然后移动到iCloud备忘录中 iCloud Drive 简介：即iCloud云盘，相当于我们平时用的百度网盘，用于不同苹果设备间共享文件 使用方式： mac： 1.2.1 中勾选“iCloud云盘” 访达App --> 侧边栏中找到“iCloud云盘” --> 进行文件拖拽操作 iphone： 1.2.2 中勾选“iCloud云盘” 文件App --> “浏览”tab --> 在“位置”的下拉选项中找到“iCloud云盘” 使用技巧 Apple ID账号设置iCloud后会自动获得5G的存储空间（iCloud 和 iCloud Drive共用），需付费获取额外的存储，所以需要合理安排需要存储到云端的文件 iCloud设置中不勾选“照片”项，iphone、ipad等设备的照片、视频定期备份到移动硬盘中 在mac上登陆 待备份照片 设备上的 Apple ID 账号，同步完照片后操作导出 注： 全选复制粘贴操作 会丢失视频文件，视频文件会被转化为单张图片被导出，所以备份照片一定是导出 “照片app”中的最近删除项 会被保留一个月 同样会占用5G的存储空间，所以在切换Apple ID账号登陆 同步照片之前，在“照片app”中将“最近删除”中的所有项进行“全部删除”操作（iphone、mac、https://www.icloud.com.cn/ 等上面操作都可以） iphone iCloud设置中不勾选“iCloud云备份”，平时没啥必要 定期清理、整理云文件 Mac 系统，如何卸载自启动的 creative cloud 背景：大乖需要用photoshop进行简单P图，不想去研究破解，正版免费试用期时间又非常短，但正版免费试用期限制的单位是单台电脑，所以用她公司电脑的试用期过期后，把软件又安装到了我的mac上进行试用 问题：过后，creative cloud开机自启动无法禁止，顽固无法卸载 解决方案：安装 creative_cloud_uninstallermac "},"doc/Resume.html":{"url":"doc/Resume.html","title":"简历","keywords":"","body":"田硕 男｜18601266033｜tsleader@aliyun.com｜天津籍 教育经历 2011-2015 江苏大学 本科 期望职位 Web前端开发工程师 专业技能 熟练掌握HTML5、CSS3及各类布局，像素级还原设计稿 熟练掌握JavaScript基本语法和ES6规范 熟练使用Vue2.0全家桶 熟悉Echarts、AntV等可视化工具 了解TypeScript、Webpack的基本使用 工作经历 时间 公司 岗位 2019.06-2021.08 北京红孩子互联科技有限公司 Web前端开发工程师 2017.07-2019.03 怡和祥云（北京）科技有限公司 Web前端开发工程师 备注：其中2019.04-2019.05这段时间去考取了摩托车驾照 项目经验 苏宁礼遇（包含H5、微信小程序、PC管理后台三端） 项目描述：苏宁大客户提供从企业采购基础产品到企业供应链全场景解决方案，为政府、企业提供行政物资、年节福利、渠道营销、工业品、地产精装配套等采购服务。前期参与了包括首页、商品四级页、热销排行榜、福利转赠、个人中心等多个页面的开发工作，后来独立负责H5项目的开发与版本迭代 H5 使用Vue + Webpack构建页面框架 使用flyio进行ajax请求 使用Vue-router管理路由，Vuex管理数据 封装公共组件、全局过滤器、自定义指令、工具类 使用mixin将多个组件的相同业务逻辑抽离 优化构建速度、优化产出代码 使用keep-alive对频繁切换展示隐藏的组件进行缓存 路由组件异步加载 bundle加hash 合理使用base64转化小图片 优化babel IgnorePlugin忽略特定模块 多进程打包、压缩js scope hoisting CDN 微信小程序 根据业务需求合理分包 二次封装wx.request，加入登陆拦截 抽离组件，精简单个复杂页面代码量 母账号后台管理页面 重构java ftl项目，实现前后端分离 使用Vue + TS + ElementUI搭建项目 使用axios进行ajax请求 使用Echarts实现各种饼图、柱状图、热力图等 专属商城（前后端未分离项目） 项目描述：苏宁旗下大客户企业采购专属平台。主要负责地址管理、订单管理、发票管理、常购清单等页面的开发 使用phpstudy_pro对前端代码进行启动服务、代理调试 灵活使用jQuery及validata.js、fileupload.js、daterangepicker.js等插件 页面响应速度调优 降低重排范围、减少重排次数 集中修改样式 DOM读写分离 DOM离线 使用position: absolute || fixed;脱离文档流 给瀑布流图片添加懒加载 输入框模糊查询、窗口resize页面scroll调用接口 做防抖、节流 给前端静态文件资源加时间戳，配合服务端做强制缓存、协商缓存 "}}